"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./services/api.ts":
/*!*************************!*\
  !*** ./services/api.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiService: () => (/* binding */ apiService)\n/* harmony export */ });\n/* harmony import */ var _mockData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mockData */ \"(app-pages-browser)/./services/mockData.ts\");\n\n\nclass ApiService {\n    async login(username, password) {\n        // Mock authentication\n        const user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.find((u)=>u.username === username);\n        if (!user) {\n            throw new Error('Invalid credentials');\n        }\n        this.currentUser = user;\n        localStorage.setItem('currentUser', JSON.stringify(user));\n        return user;\n    }\n    getCurrentUser() {\n        if (!this.currentUser) {\n            const stored = localStorage.getItem('currentUser');\n            if (stored) {\n                this.currentUser = JSON.parse(stored);\n            }\n        }\n        return this.currentUser;\n    }\n    logout() {\n        this.currentUser = null;\n        localStorage.removeItem('currentUser');\n    }\n    generateQRValue(metadata1, index) {\n        const parts = [\n            metadata1.bankName,\n            metadata1.merchantName,\n            metadata1.merchantId\n        ];\n        if (metadata1.terminalId) {\n            parts.push(metadata1.terminalId);\n        }\n        return parts.join('\\n');\n    }\n    async generateQRCodes(count, type, metadata1) {\n        // Validate mandatory fields\n        if (!(metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.bankName) || !(metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.merchantName) || !(metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.merchantId)) {\n            throw new Error('Bank Name, Merchant Name, and Merchant ID are required fields');\n        }\n        // Mock QR generation\n        const newQRs = Array.from({\n            length: count\n        }, (_, i)=>({\n                id: \"qr_gen_\".concat(Date.now(), \"_\").concat(i),\n                qrValue: this.generateQRValue(metadata1, i),\n                qrType: type,\n                generationSource: 'system',\n                status: 'unallocated',\n                bankName: metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.bankName,\n                merchantName: metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.merchantName,\n                createdAt: new Date().toISOString(),\n                terminalId: (metadata1 === null || metadata1 === void 0 ? void 0 : metadata1.terminalId) || undefined,\n                updatedAt: new Date().toISOString()\n            }));\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.push(...newQRs);\n        this.logAction('QR_GENERATED', 'qr_code', {\n            count,\n            type\n        });\n        return newQRs;\n    }\n    async uploadQRCodes(file) {\n        // Mock file upload processing\n        const count = Math.floor(Math.random() * 50) + 10;\n        const newQRs = Array.from({\n            length: count\n        }, (_, i)=>{\n            var _metadata, _this_currentUser;\n            return {\n                id: \"qr_upload_\".concat(Date.now(), \"_\").concat(i),\n                qrValue: \"UPL\".concat(Date.now()).concat(String(i).padStart(3, '0')),\n                qrType: 'static',\n                generationSource: 'upload',\n                merchantBankAccount: (_metadata = metadata) === null || _metadata === void 0 ? void 0 : _metadata.merchantBankAccount,\n                uploadFileId: \"file_\".concat(Date.now()),\n                createdBy: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString()\n            };\n        });\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.push(...newQRs);\n        this.logAction('QR_UPLOADED', 'qr_code', {\n            filename: file.name,\n            count\n        });\n        return newQRs;\n    }\n    async getQRCodes(filters) {\n        const currentUser = this.getCurrentUser();\n        let qrs = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes\n        ];\n        if (filters === null || filters === void 0 ? void 0 : filters.status) {\n            qrs = qrs.filter((qr)=>qr.status === filters.status);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.branchId) {\n            qrs = qrs.filter((qr)=>qr.allocatedBranchId === filters.branchId);\n        }\n        // For sales users, show only their QRs\n        if ((currentUser === null || currentUser === void 0 ? void 0 : currentUser.role) === 'SALES_USER') {\n            qrs = qrs.filter((qr)=>qr.allocatedToUserId === currentUser.id);\n        }\n        return qrs;\n    }\n    async allocateQRsToBranch(qrIds, branchId) {\n        qrIds.forEach((qrId)=>{\n            const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n            if (qr) {\n                qr.status = 'allocated';\n                qr.allocatedBranchId = branchId;\n                qr.updatedAt = new Date().toISOString();\n            }\n        });\n        this.logAction('QR_ALLOCATED', 'qr_code', {\n            qrIds,\n            branchId\n        });\n    }\n    async createAllocationRequest(data) {\n        var _this_currentUser;\n        const request = {\n            id: \"req_\".concat(Date.now()),\n            requestNumber: \"REQ\".concat(String(_mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.length + 1).padStart(3, '0')),\n            branchId: data.branchId,\n            initiatorUserId: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n            requestedQrCount: data.requestedQrCount,\n            requestedFor: data.requestedFor,\n            status: 'pending',\n            notes: data.notes || '',\n            createdAt: new Date().toISOString()\n        };\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.push(request);\n        this.logAction('REQUEST_CREATED', 'allocation_request', request);\n        return request;\n    }\n    async approveRequest(requestId, notes) {\n        const request = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'approved';\n            request.approverUserId = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.approvedAt = new Date().toISOString();\n            if (notes) request.notes += \"\\nApproval notes: \".concat(notes);\n        }\n        this.logAction('REQUEST_APPROVED', 'allocation_request', {\n            requestId,\n            notes\n        });\n    }\n    async rejectRequest(requestId, reason) {\n        const request = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'rejected';\n            request.approverUserId = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.notes += \"\\nRejection reason: \".concat(reason);\n        }\n        this.logAction('REQUEST_REJECTED', 'allocation_request', {\n            requestId,\n            reason\n        });\n    }\n    async returnRequestForCorrection(requestId, reason) {\n        const request = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'pending';\n            request.approverUserId = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.notes += \"\\nReturned for correction: \".concat(reason);\n        }\n        this.logAction('REQUEST_RETURNED_FOR_CORRECTION', 'allocation_request', {\n            requestId,\n            reason\n        });\n    }\n    async updateAllocationRequest(requestId, updates) {\n        const request = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.find((r)=>r.id === requestId);\n        if (request) {\n            Object.assign(request, updates);\n            request.status = 'pending'; // Reset to pending when edited\n        }\n        this.logAction('REQUEST_UPDATED', 'allocation_request', {\n            requestId,\n            updates\n        });\n    }\n    async getAllocationRequests(branchId) {\n        const currentUser = this.getCurrentUser();\n        let requests = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests\n        ];\n        if (branchId) {\n            requests = requests.filter((r)=>r.branchId === branchId);\n        }\n        // For sales users, show only their requests\n        if ((currentUser === null || currentUser === void 0 ? void 0 : currentUser.role) === 'SALES_USER') {\n            requests = requests.filter((r)=>r.initiatorUserId === currentUser.id);\n        }\n        return requests;\n    }\n    async issueQRToMerchant(qrId, merchantData) {\n        const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n        if (qr) {\n            qr.status = 'issued';\n            qr.issuedToMerchantId = merchantData.id;\n            qr.updatedAt = new Date().toISOString();\n        }\n        this.logAction('QR_ISSUED', 'qr_code', {\n            qrId,\n            merchantData\n        });\n    }\n    async returnQR(qrId, reason, condition) {\n        var _this_currentUser;\n        const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n        if (qr) {\n            qr.status = 'returned';\n            qr.updatedAt = new Date().toISOString();\n        }\n        const returnRecord = {\n            id: \"ret_\".concat(Date.now()),\n            qrId,\n            returnedByUserId: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n            returnedAt: new Date().toISOString(),\n            reason,\n            condition,\n            status: 'pending'\n        };\n        this.logAction('QR_RETURNED', 'qr_code', {\n            qrId,\n            reason,\n            condition\n        });\n        return returnRecord;\n    }\n    async getDashboardStats(branchId) {\n        var _branches_find;\n        const qrs = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes;\n        const requests = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests;\n        const users = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers;\n        const branches = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches;\n        // Filter data by branch if branchId is provided (for branch approvers)\n        const filteredQRs = branchId ? qrs.filter((q)=>q.allocatedBranchId === branchId) : qrs;\n        const filteredRequests = branchId ? requests.filter((r)=>r.branchId === branchId) : requests;\n        const filteredUsers = branchId ? users.filter((u)=>u.branchId === branchId) : users;\n        const filteredActivity = branchId ? _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditLogs.filter((log)=>{\n            var _log_payload;\n            // Filter activity by branch-related actions\n            return ((_log_payload = log.payload) === null || _log_payload === void 0 ? void 0 : _log_payload.branchId) === branchId || log.targetEntity === 'allocation_request' && filteredRequests.some((r)=>{\n                var _log_payload;\n                return r.id === ((_log_payload = log.payload) === null || _log_payload === void 0 ? void 0 : _log_payload.requestId);\n            });\n        }) : _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditLogs;\n        // Sync QR codes with users and branches\n        this.syncQRCodesWithUsersAndBranches();\n        // Calculate accurate counts based on role and user context\n        const currentUser = this.getCurrentUser();\n        let totalQRs, unallocated, allocated, issued, returned, blocked;\n        if (branchId) {\n            // For branch-specific roles (branch managers, approvers, sales users)\n            totalQRs = filteredQRs.length;\n            unallocated = 0; // Branch users don't see unallocated QRs\n            allocated = filteredQRs.filter((q)=>q.status === 'allocated').length;\n            issued = filteredQRs.filter((q)=>q.status === 'issued').length;\n            returned = filteredQRs.filter((q)=>q.status === 'returned').length;\n            blocked = filteredQRs.filter((q)=>q.status === 'blocked').length;\n            // For sales users, further filter to show only their issued QRs\n            if ((currentUser === null || currentUser === void 0 ? void 0 : currentUser.role) === 'SALES_USER') {\n                const userIssuedQRs = filteredQRs.filter((q)=>q.allocatedToUserId === currentUser.id);\n                totalQRs = userIssuedQRs.length;\n                allocated = userIssuedQRs.filter((q)=>q.status === 'allocated').length;\n                issued = userIssuedQRs.filter((q)=>q.status === 'issued').length;\n                returned = userIssuedQRs.filter((q)=>q.status === 'returned').length;\n                blocked = userIssuedQRs.filter((q)=>q.status === 'blocked').length;\n            }\n        } else {\n            // For system admin, show system-wide data\n            totalQRs = qrs.length;\n            unallocated = qrs.filter((q)=>q.status === 'unallocated').length;\n            allocated = qrs.filter((q)=>q.status === 'allocated').length;\n            issued = qrs.filter((q)=>q.status === 'issued').length;\n            returned = qrs.filter((q)=>q.status === 'returned').length;\n            blocked = qrs.filter((q)=>q.status === 'blocked').length;\n        }\n        // Branch approver specific stats\n        const pendingApprovals = filteredRequests.filter((r)=>r.status === 'pending').length;\n        const approvedRequests = filteredRequests.filter((r)=>r.status === 'approved').length;\n        const rejectedRequests = filteredRequests.filter((r)=>r.status === 'rejected').length;\n        const returnedForCorrection = filteredRequests.filter((r)=>{\n            var _r_notes;\n            return r.status === 'pending' && ((_r_notes = r.notes) === null || _r_notes === void 0 ? void 0 : _r_notes.includes('Returned for correction'));\n        }).length;\n        // Calculate pending KYC requests\n        const pendingKYC = branchId ? this.kycRequests.filter((kyc)=>kyc.branchId === branchId && kyc.status === 'pending').length : this.kycRequests.filter((kyc)=>kyc.status === 'pending').length;\n        // Top sellers filtered by branch\n        const topSellers = branchId ? this.getTopSellersByBranch(branchId, (currentUser === null || currentUser === void 0 ? void 0 : currentUser.role) === 'SALES_USER' ? currentUser.id : undefined) : this.getTopSellersGlobal();\n        // Top branches and regions - consistent with actual data\n        const topBranches = branchId ? [\n            {\n                name: ((_branches_find = branches.find((b)=>b.id === branchId)) === null || _branches_find === void 0 ? void 0 : _branches_find.name) || 'Current Branch',\n                count: issued\n            }\n        ] : [\n            {\n                name: 'Downtown Branch',\n                count: qrs.filter((q)=>q.allocatedBranchId === '1' && q.status === 'issued').length\n            },\n            {\n                name: 'Uptown Branch',\n                count: qrs.filter((q)=>q.allocatedBranchId === '2' && q.status === 'issued').length\n            },\n            {\n                name: 'Westside Branch',\n                count: qrs.filter((q)=>q.allocatedBranchId === '3' && q.status === 'issued').length\n            }\n        ];\n        const topRegions = !branchId ? [\n            {\n                name: 'Central Region',\n                count: qrs.filter((q)=>q.allocatedBranchId === '1' && q.status === 'issued').length,\n                branchCount: 1\n            },\n            {\n                name: 'North Region',\n                count: qrs.filter((q)=>q.allocatedBranchId === '2' && q.status === 'issued').length,\n                branchCount: 1\n            },\n            {\n                name: 'West Region',\n                count: qrs.filter((q)=>q.allocatedBranchId === '3' && q.status === 'issued').length,\n                branchCount: 1\n            }\n        ] : undefined;\n        return {\n            totalQRs,\n            unallocated,\n            allocated,\n            issued,\n            returned,\n            blocked,\n            pendingApprovals,\n            approvedRequests,\n            rejectedRequests,\n            returnedForCorrection,\n            topBranches,\n            topSellers,\n            topRegions,\n            recentActivity: filteredActivity.slice(-10),\n            pendingKYC\n        };\n    }\n    // Sync QR codes with users and branches to ensure data consistency\n    syncQRCodesWithUsersAndBranches() {\n        // Update QR codes to reflect current branch and user assignments\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.forEach((qr)=>{\n            // Ensure allocated QRs have valid branch assignments\n            if (qr.status === 'allocated' && qr.allocatedBranchId) {\n                const branch = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.find((b)=>b.id === qr.allocatedBranchId);\n                if (!branch) {\n                    // Branch no longer exists, reset QR to unallocated\n                    qr.status = 'unallocated';\n                    qr.allocatedBranchId = undefined;\n                    qr.allocatedToUserId = undefined;\n                }\n            }\n            // Ensure issued QRs have valid user assignments\n            if (qr.status === 'issued' && qr.allocatedToUserId) {\n                const user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.find((u)=>u.id === qr.allocatedToUserId);\n                if (!user || user.status === 'inactive') {\n                    // User no longer exists or is inactive, return QR to allocated status\n                    qr.status = 'allocated';\n                    qr.allocatedToUserId = undefined;\n                    qr.issuedToMerchantId = undefined;\n                }\n            }\n        });\n        // Log sync action\n        this.logAction('DATA_SYNC', 'system', {\n            timestamp: new Date().toISOString(),\n            qrCount: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.length,\n            userCount: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.length,\n            branchCount: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.length\n        });\n    }\n    getTopSellersByBranch(branchId, currentUserId) {\n        var _mockBranches_find;\n        const branchName = ((_mockBranches_find = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.find((b)=>b.id === branchId)) === null || _mockBranches_find === void 0 ? void 0 : _mockBranches_find.name) || 'Unknown Branch';\n        let branchUsers = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.filter((u)=>u.branchId === branchId && u.role === 'SALES_USER');\n        // If currentUserId is provided (for sales users), show only their data\n        if (currentUserId) {\n            branchUsers = branchUsers.filter((u)=>u.id === currentUserId);\n        }\n        return branchUsers.map((user)=>{\n            const issuedCount = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.filter((qr)=>qr.allocatedBranchId === branchId && qr.status === 'issued' && qr.allocatedToUserId === user.id).length;\n            return {\n                name: user.name,\n                count: issuedCount,\n                branch: branchName,\n                userId: user.id\n            };\n        }).sort((a, b)=>b.count - a.count);\n    }\n    getTopSellersGlobal() {\n        const salesUsers = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.filter((u)=>u.role === 'sales_user');\n        return salesUsers.map((user)=>{\n            var _mockBranches_find;\n            const branchName = ((_mockBranches_find = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.find((b)=>b.id === user.branchId)) === null || _mockBranches_find === void 0 ? void 0 : _mockBranches_find.name) || 'Unknown Branch';\n            const issuedCount = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.filter((qr)=>qr.status === 'issued' && qr.allocatedToUserId === user.id).length;\n            return {\n                name: user.name,\n                count: issuedCount,\n                branch: branchName,\n                userId: user.id\n            };\n        }).sort((a, b)=>b.count - a.count);\n    }\n    async exportData(type) {\n        // Mock CSV export\n        let csvData = '';\n        switch(type){\n            case 'qr_codes':\n                csvData = 'ID,QR Value,Type,Status,Branch,Created At\\n';\n                _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.forEach((qr)=>{\n                    csvData += \"\".concat(qr.id, \",\").concat(qr.qrValue, \",\").concat(qr.qrType, \",\").concat(qr.status, \",\").concat(qr.allocatedBranchId || 'N/A', \",\").concat(qr.createdAt, \"\\n\");\n                });\n                break;\n            case 'allocations':\n                csvData = 'Request ID,Branch,Count,Status,Created At\\n';\n                _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAllocationRequests.forEach((req)=>{\n                    csvData += \"\".concat(req.requestNumber, \",\").concat(req.branchId, \",\").concat(req.requestedQrCount, \",\").concat(req.status, \",\").concat(req.createdAt, \"\\n\");\n                });\n                break;\n        }\n        return new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n    }\n    // User Management\n    async createUser(userData) {\n        const newUser = {\n            id: \"user_\".concat(Date.now()),\n            username: userData.username,\n            email: userData.email,\n            name: userData.name,\n            role: userData.role,\n            branchId: userData.branchId,\n            phone: userData.phone,\n            status: 'active',\n            createdAt: new Date().toISOString()\n        };\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.push(newUser);\n        this.logAction('USER_CREATED', 'user', newUser);\n        return newUser;\n    }\n    async getUsers() {\n        return [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers\n        ];\n    }\n    async updateUser(userId, updates) {\n        const userIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.findIndex((u)=>u.id === userId);\n        if (userIndex === -1) throw new Error('User not found');\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers[userIndex] = {\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers[userIndex],\n            ...updates\n        };\n        this.logAction('USER_UPDATED', 'user', {\n            userId,\n            updates\n        });\n        return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers[userIndex];\n    }\n    // Branch Management\n    async createBranch(branchData) {\n        const newBranch = {\n            id: \"branch_\".concat(Date.now()),\n            branchCode: branchData.branchCode,\n            name: branchData.name,\n            region: branchData.region,\n            type: branchData.type,\n            state: branchData.state,\n            country: branchData.country,\n            isActive: true,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.push(newBranch);\n        this.logAction('BRANCH_CREATED', 'branch', newBranch);\n        return newBranch;\n    }\n    async getBranches() {\n        return [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches\n        ];\n    }\n    async updateBranch(branchId, updates) {\n        const branchIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.findIndex((b)=>b.id === branchId);\n        if (branchIndex === -1) throw new Error('Branch not found');\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches[branchIndex] = {\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches[branchIndex],\n            ...updates,\n            updatedAt: new Date().toISOString()\n        };\n        this.logAction('BRANCH_UPDATED', 'branch', {\n            branchId,\n            updates\n        });\n        return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches[branchIndex];\n    }\n    async deleteBranch(branchId) {\n        const branchIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.findIndex((b)=>b.id === branchId);\n        if (branchIndex === -1) throw new Error('Branch not found');\n        // Check if branch has users\n        const branchUsers = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.filter((u)=>u.branchId === branchId);\n        if (branchUsers.length > 0) {\n            throw new Error('Cannot delete branch with existing users. Please reassign users first.');\n        }\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.splice(branchIndex, 1);\n        this.logAction('BRANCH_DELETED', 'branch', {\n            branchId\n        });\n    }\n    async getDistinctRegions() {\n        const regions = new Set(_mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.map((b)=>b.region));\n        return Array.from(regions);\n    }\n    async searchBranches(searchTerm) {\n        const term = searchTerm.toLowerCase();\n        return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.filter((branch)=>branch.name.toLowerCase().includes(term) || branch.branchCode.toLowerCase().includes(term) || branch.region.toLowerCase().includes(term));\n    }\n    // Branch Inventory Management\n    async getBranchInventory(branchId) {\n        const currentUser = this.getCurrentUser();\n        const branches = branchId ? _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches.filter((b)=>b.id === branchId) : _mockData__WEBPACK_IMPORTED_MODULE_0__.mockBranches;\n        return branches.map((branch)=>{\n            const branchQRs = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.filter((qr)=>qr.allocatedBranchId === branch.id);\n            let totalAllocated, issued, available, returned, blocked;\n            // For sales users, show only their QRs\n            if ((currentUser === null || currentUser === void 0 ? void 0 : currentUser.role) === 'sales_user' && currentUser.branchId === branch.id) {\n                const userQRs = branchQRs.filter((qr)=>qr.allocatedToUserId === currentUser.id);\n                totalAllocated = userQRs.length;\n                issued = userQRs.filter((qr)=>qr.status === 'issued').length;\n                available = userQRs.filter((qr)=>qr.status === 'allocated').length;\n                returned = userQRs.filter((qr)=>qr.status === 'returned').length;\n                blocked = userQRs.filter((qr)=>qr.status === 'blocked').length;\n            } else {\n                // For other roles, show branch-wide data\n                totalAllocated = branchQRs.length;\n                issued = branchQRs.filter((qr)=>qr.status === 'issued').length;\n                available = branchQRs.filter((qr)=>qr.status === 'allocated').length;\n                returned = branchQRs.filter((qr)=>qr.status === 'returned').length;\n                blocked = branchQRs.filter((qr)=>qr.status === 'blocked').length;\n            }\n            const utilizationRate = totalAllocated > 0 ? Math.round(issued / totalAllocated * 100) : 0;\n            return {\n                branchId: branch.id,\n                branchName: branch.name,\n                branchCode: branch.branchCode,\n                totalAllocated,\n                issued,\n                available,\n                returned,\n                blocked,\n                utilizationRate,\n                lastActivity: new Date().toISOString()\n            };\n        });\n    }\n    // Bulk QR Allocation\n    async bulkAllocateQRs(branchId, count) {\n        const unallocatedQRs = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.filter((qr)=>qr.status === 'unallocated').slice(0, count);\n        if (unallocatedQRs.length < count) {\n            throw new Error(\"Only \".concat(unallocatedQRs.length, \" unallocated QR codes available\"));\n        }\n        unallocatedQRs.forEach((qr)=>{\n            qr.status = 'allocated';\n            qr.allocatedBranchId = branchId;\n            qr.updatedAt = new Date().toISOString();\n        });\n        this.logAction('BULK_QR_ALLOCATED', 'qr_code', {\n            branchId,\n            count,\n            qrIds: unallocatedQRs.map((qr)=>qr.id)\n        });\n    }\n    // Bulk QR Assignment between branches\n    async bulkAssignQRs(sourceBranchId, targetBranchId, count) {\n        const sourceQRs = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.filter((qr)=>qr.allocatedBranchId === sourceBranchId && qr.status === 'allocated').slice(0, count);\n        if (sourceQRs.length < count) {\n            throw new Error(\"Only \".concat(sourceQRs.length, \" available QR codes in source branch\"));\n        }\n        sourceQRs.forEach((qr)=>{\n            qr.allocatedBranchId = targetBranchId;\n            qr.updatedAt = new Date().toISOString();\n        });\n        this.logAction('BULK_QR_ASSIGNED', 'qr_code', {\n            sourceBranchId,\n            targetBranchId,\n            count,\n            qrIds: sourceQRs.map((qr)=>qr.id)\n        });\n    }\n    // Threshold Requests\n    async createThresholdRequest(branchId, data) {\n        var _this_currentUser;\n        const request = {\n            id: \"thresh_\".concat(Date.now()),\n            branchId,\n            currentInventory: data.currentInventory,\n            threshold: data.threshold,\n            requestedAmount: data.requestedAmount,\n            reason: data.reason,\n            status: 'pending',\n            createdBy: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n            createdAt: new Date().toISOString()\n        };\n        this.thresholdRequests.push(request);\n        this.logAction('THRESHOLD_REQUEST_CREATED', 'threshold_request', request);\n        return request;\n    }\n    async getThresholdRequests(branchId) {\n        let requests = [\n            ...this.thresholdRequests\n        ];\n        if (branchId) {\n            requests = requests.filter((r)=>r.branchId === branchId);\n        }\n        return requests.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    }\n    async approveThresholdRequest(requestId, notes) {\n        const request = this.thresholdRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'approved';\n            request.reviewedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.reviewedAt = new Date().toISOString();\n            // Auto-allocate the requested QRs\n            await this.bulkAllocateQRs(request.branchId, request.requestedAmount);\n        }\n        this.logAction('THRESHOLD_REQUEST_APPROVED', 'threshold_request', {\n            requestId,\n            notes\n        });\n    }\n    async rejectThresholdRequest(requestId, reason) {\n        const request = this.thresholdRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'rejected';\n            request.reviewedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.reviewedAt = new Date().toISOString();\n        }\n        this.logAction('THRESHOLD_REQUEST_REJECTED', 'threshold_request', {\n            requestId,\n            reason\n        });\n    }\n    // Merchant Management\n    async createMerchant(merchantData) {\n        var _this_currentUser;\n        const newMerchant = {\n            id: \"merchant_\".concat(Date.now()),\n            legalName: merchantData.legalName,\n            shopName: merchantData.shopName,\n            address: merchantData.address,\n            phone: merchantData.phone,\n            email: merchantData.email,\n            kycStatus: 'pending',\n            branchId: (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.branchId,\n            createdAt: new Date().toISOString()\n        };\n        this.merchants.push(newMerchant);\n        this.logAction('MERCHANT_CREATED', 'merchant', newMerchant);\n        return newMerchant;\n    }\n    async getMerchants(branchId) {\n        // Filter merchants by branch if branchId is provided\n        if (branchId) {\n            return this.merchants.filter((m)=>m.branchId === branchId);\n        }\n        return [\n            ...this.merchants\n        ];\n    }\n    async deleteMerchant(merchantId) {\n        const merchantIndex = this.merchants.findIndex((m)=>m.id === merchantId);\n        if (merchantIndex === -1) throw new Error('Merchant not found');\n        this.merchants.splice(merchantIndex, 1);\n        this.logAction('MERCHANT_DELETED', 'merchant', {\n            merchantId\n        });\n    }\n    // Merchant QR Requests\n    async createMerchantQRRequest(data) {\n        var _this_currentUser, _this_currentUser1;\n        const request = {\n            id: \"mer_req_\".concat(Date.now()),\n            merchantId: data.merchantId,\n            requestedBy: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n            branchId: ((_this_currentUser1 = this.currentUser) === null || _this_currentUser1 === void 0 ? void 0 : _this_currentUser1.branchId) || '1',\n            requestedQrCount: data.requestedQrCount,\n            businessJustification: data.businessJustification,\n            status: 'pending',\n            createdAt: new Date().toISOString()\n        };\n        this.merchantRequests.push(request);\n        this.logAction('MERCHANT_QR_REQUEST_CREATED', 'merchant_request', request);\n        return request;\n    }\n    async getMerchantQRRequests(branchId) {\n        let requests = [\n            ...this.merchantRequests\n        ];\n        if (branchId) {\n            requests = requests.filter((r)=>r.branchId === branchId);\n        }\n        return requests.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    }\n    async approveMerchantQRRequest(requestId, notes) {\n        const request = this.merchantRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'approved';\n            request.approvedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.approvedAt = new Date().toISOString();\n            // Auto-allocate QRs to the requesting branch\n            await this.bulkAllocateQRs(request.branchId, request.requestedQrCount);\n        }\n        this.logAction('MERCHANT_QR_REQUEST_APPROVED', 'merchant_request', {\n            requestId,\n            notes\n        });\n    }\n    async rejectMerchantQRRequest(requestId, reason) {\n        const request = this.merchantRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'rejected';\n            request.approvedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.rejectionReason = reason;\n        }\n        this.logAction('MERCHANT_QR_REQUEST_REJECTED', 'merchant_request', {\n            requestId,\n            reason\n        });\n    }\n    // KYC Management\n    async createKYCRequest(data) {\n        var _this_currentUser, _this_currentUser1;\n        // Check if KYC request already exists for this merchant\n        const existingRequest = this.kycRequests.find((r)=>r.merchantId === data.merchantId && r.status === 'pending');\n        if (existingRequest) {\n            throw new Error('A KYC request is already pending for this merchant');\n        }\n        const request = {\n            id: \"kyc_\".concat(Date.now()),\n            merchantId: data.merchantId,\n            requestedBy: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '1',\n            branchId: ((_this_currentUser1 = this.currentUser) === null || _this_currentUser1 === void 0 ? void 0 : _this_currentUser1.branchId) || '1',\n            status: 'pending',\n            documents: data.documents,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        this.kycRequests.push(request);\n        this.logAction('KYC_REQUEST_CREATED', 'kyc_request', request);\n        return request;\n    }\n    async getKYCRequests(branchId) {\n        let requests = [\n            ...this.kycRequests\n        ];\n        if (branchId) {\n            requests = requests.filter((r)=>r.branchId === branchId);\n        }\n        return requests.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    }\n    async approveKYCRequest(requestId, notes) {\n        const request = this.kycRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'approved';\n            request.reviewedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.reviewedAt = new Date().toISOString();\n            request.reviewNotes = notes;\n            request.updatedAt = new Date().toISOString();\n            // Update merchant KYC status\n            const merchant = this.merchants.find((m)=>m.id === request.merchantId);\n            if (merchant) {\n                merchant.kycStatus = 'verified';\n            }\n        }\n        this.logAction('KYC_REQUEST_APPROVED', 'kyc_request', {\n            requestId,\n            notes\n        });\n    }\n    async rejectKYCRequest(requestId, reason) {\n        const request = this.kycRequests.find((r)=>r.id === requestId);\n        if (request) {\n            var _this_currentUser;\n            request.status = 'rejected';\n            request.reviewedBy = (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id;\n            request.reviewedAt = new Date().toISOString();\n            request.reviewNotes = reason;\n            request.updatedAt = new Date().toISOString();\n            // Update merchant KYC status\n            const merchant = this.merchants.find((m)=>m.id === request.merchantId);\n            if (merchant) {\n                merchant.kycStatus = 'rejected';\n            }\n        }\n        this.logAction('KYC_REQUEST_REJECTED', 'kyc_request', {\n            requestId,\n            reason\n        });\n    }\n    // Audit Management (for Auditor role)\n    async getAuditLogs(filters) {\n        let logs = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditLogs\n        ];\n        if (filters === null || filters === void 0 ? void 0 : filters.dateFrom) {\n            logs = logs.filter((log)=>new Date(log.timestamp) >= new Date(filters.dateFrom));\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.dateTo) {\n            logs = logs.filter((log)=>new Date(log.timestamp) <= new Date(filters.dateTo));\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.actionType) {\n            logs = logs.filter((log)=>log.actionType === filters.actionType);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.userId) {\n            logs = logs.filter((log)=>log.actorUserId === filters.userId);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.branchId) {\n            logs = logs.filter((log)=>{\n                var _log_payload;\n                return ((_log_payload = log.payload) === null || _log_payload === void 0 ? void 0 : _log_payload.branchId) === filters.branchId;\n            });\n        }\n        return logs.sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n    }\n    async generateAuditReport(type, filters) {\n        var _this_currentUser;\n        const logs = await this.getAuditLogs(filters);\n        const report = {\n            id: \"audit_report_\".concat(Date.now()),\n            type,\n            generatedBy: (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id,\n            generatedAt: new Date().toISOString(),\n            filters,\n            summary: this.generateAuditSummary(logs, type),\n            details: this.generateAuditDetails(logs, type),\n            recommendations: this.generateAuditRecommendations(logs, type)\n        };\n        this.logAction('AUDIT_REPORT_GENERATED', 'audit_report', {\n            reportType: type,\n            filters\n        });\n        return report;\n    }\n    // Audit Item Management (for Auditor role)\n    async getAuditItems(filters) {\n        let items = [\n            ...this.auditItems\n        ];\n        if (filters === null || filters === void 0 ? void 0 : filters.category) {\n            items = items.filter((item)=>item.category === filters.category);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.status) {\n            items = items.filter((item)=>item.status === filters.status);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.riskLevel) {\n            items = items.filter((item)=>item.riskLevel === filters.riskLevel);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.branchId) {\n            items = items.filter((item)=>item.branchId === filters.branchId);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.dueDate) {\n            const filterDate = new Date(filters.dueDate);\n            items = items.filter((item)=>new Date(item.dueDate) <= filterDate);\n        }\n        return items.sort((a, b)=>new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());\n    }\n    async updateAuditItem(itemId, updates) {\n        var _this_currentUser;\n        const itemIndex = this.auditItems.findIndex((item)=>item.id === itemId);\n        if (itemIndex === -1) throw new Error('Audit item not found');\n        const updatedItem = {\n            ...this.auditItems[itemIndex],\n            ...updates,\n            auditedBy: (_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id,\n            auditedAt: new Date().toISOString(),\n            lastReviewDate: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        this.auditItems[itemIndex] = updatedItem;\n        this.logAction('AUDIT_ITEM_UPDATED', 'audit_item', {\n            itemId,\n            updates\n        });\n        return updatedItem;\n    }\n    async createAuditItem(itemData) {\n        const newItem = {\n            id: \"audit_item_\".concat(Date.now()),\n            category: itemData.category,\n            subcategory: itemData.subcategory,\n            title: itemData.title,\n            description: itemData.description,\n            riskLevel: itemData.riskLevel,\n            status: 'pending',\n            dueDate: itemData.dueDate,\n            evidence: [],\n            targetEntity: itemData.targetEntity,\n            targetEntityId: itemData.targetEntityId,\n            branchId: itemData.branchId,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        this.auditItems.push(newItem);\n        this.logAction('AUDIT_ITEM_CREATED', 'audit_item', newItem);\n        return newItem;\n    }\n    async getAuditChecklists() {\n        // Update checklist scores based on current audit items\n        return this.auditChecklists.map((checklist)=>{\n            const items = this.auditItems.filter((item)=>checklist.items.some((checklistItem)=>checklistItem.id === item.id));\n            const completedItems = items.filter((item)=>item.status === 'compliant' || item.status === 'non_compliant' || item.status === 'requires_action');\n            const totalScore = items.reduce((sum, item)=>sum + (item.score || 0), 0);\n            const avgScore = items.length > 0 ? totalScore / items.length : 0;\n            const completionRate = items.length > 0 ? completedItems.length / items.length * 100 : 0;\n            return {\n                ...checklist,\n                items,\n                overallScore: Math.round(avgScore),\n                completionRate: Math.round(completionRate)\n            };\n        });\n    }\n    async generateAuditScorecard() {\n        let period = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'current';\n        var _this_currentUser;\n        const items = this.auditItems;\n        const categories = [\n            'qr_management',\n            'user_access',\n            'data_protection',\n            'process_compliance',\n            'security_controls',\n            'kyc_verification'\n        ];\n        const categoryScores = categories.map((category)=>{\n            const categoryItems = items.filter((item)=>item.category === category);\n            const compliantCount = categoryItems.filter((item)=>item.status === 'compliant').length;\n            const nonCompliantCount = categoryItems.filter((item)=>item.status === 'non_compliant').length;\n            const pendingCount = categoryItems.filter((item)=>item.status === 'pending' || item.status === 'in_review').length;\n            const totalScore = categoryItems.reduce((sum, item)=>sum + (item.score || 0), 0);\n            const avgScore = categoryItems.length > 0 ? totalScore / categoryItems.length : 100;\n            return {\n                category: category.replace('_', ' ').replace(/\\b\\w/g, (l)=>l.toUpperCase()),\n                score: Math.round(avgScore),\n                itemCount: categoryItems.length,\n                compliantCount,\n                nonCompliantCount,\n                pendingCount\n            };\n        });\n        const overallScore = Math.round(categoryScores.reduce((sum, cat)=>sum + cat.score, 0) / categoryScores.length);\n        const highRiskIssues = items.filter((item)=>item.riskLevel === 'high' || item.riskLevel === 'critical').filter((item)=>item.status === 'non_compliant' || item.status === 'requires_action').length;\n        const riskLevel = highRiskIssues > 2 ? 'high' : highRiskIssues > 0 ? 'medium' : 'low';\n        return {\n            id: \"scorecard_\".concat(Date.now()),\n            period,\n            overallScore,\n            categoryScores,\n            riskAssessment: {\n                level: riskLevel,\n                score: overallScore,\n                issues: highRiskIssues,\n                recommendations: this.generateScorcardRecommendations(items)\n            },\n            trends: {\n                previousScore: overallScore - 2.3,\n                change: 2.3,\n                trend: 'improving'\n            },\n            generatedAt: new Date().toISOString(),\n            generatedBy: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || '9'\n        };\n    }\n    generateScorcardRecommendations(items) {\n        const recommendations = [];\n        const nonCompliantItems = items.filter((item)=>item.status === 'non_compliant');\n        const requiresActionItems = items.filter((item)=>item.status === 'requires_action');\n        const pendingItems = items.filter((item)=>item.status === 'pending');\n        if (nonCompliantItems.length > 0) {\n            recommendations.push(\"Address \".concat(nonCompliantItems.length, \" non-compliant items immediately\"));\n        }\n        if (requiresActionItems.length > 0) {\n            recommendations.push(\"Take action on \".concat(requiresActionItems.length, \" items requiring attention\"));\n        }\n        if (pendingItems.length > 0) {\n            recommendations.push(\"Complete review of \".concat(pendingItems.length, \" pending audit items\"));\n        }\n        // Add specific recommendations based on categories\n        const kycIssues = items.filter((item)=>item.category === 'kyc_verification' && (item.status === 'requires_action' || item.status === 'non_compliant'));\n        if (kycIssues.length > 0) {\n            recommendations.push('Implement automated KYC review reminders and SLA monitoring');\n        }\n        const securityIssues = items.filter((item)=>item.category === 'security_controls' && item.score && item.score < 90);\n        if (securityIssues.length > 0) {\n            recommendations.push('Enhance security controls and implement additional monitoring');\n        }\n        if (recommendations.length === 0) {\n            recommendations.push('Maintain current excellent compliance standards');\n            recommendations.push('Continue regular monitoring and review processes');\n        }\n        return recommendations;\n    }\n    generateAuditSummary(logs, type) {\n        const totalActions = logs.length;\n        const uniqueUsers = new Set(logs.map((log)=>log.actorUserId)).size;\n        const actionTypes = new Set(logs.map((log)=>log.actionType)).size;\n        switch(type){\n            case 'compliance':\n                return {\n                    totalActions,\n                    complianceScore: 96.8,\n                    criticalIssues: 0,\n                    warningIssues: 2,\n                    passedChecks: 45,\n                    failedChecks: 0\n                };\n            case 'security':\n                return {\n                    totalActions,\n                    securityScore: 98.2,\n                    securityEvents: logs.filter((log)=>log.actionType.includes('BLOCKED') || log.actionType.includes('REJECTED')).length,\n                    unauthorizedAttempts: 0,\n                    successfulLogins: logs.filter((log)=>log.actionType === 'USER_LOGIN').length,\n                    failedLogins: 0\n                };\n            case 'performance':\n                return {\n                    totalActions,\n                    avgResponseTime: '2.3 seconds',\n                    systemUptime: '99.8%',\n                    peakUsage: '85%',\n                    errorRate: '0.2%'\n                };\n            case 'user_activity':\n                return {\n                    totalActions,\n                    uniqueUsers,\n                    actionTypes,\n                    mostActiveUser: this.getMostActiveUser(logs),\n                    mostCommonAction: this.getMostCommonAction(logs)\n                };\n            default:\n                return {\n                    totalActions,\n                    uniqueUsers,\n                    actionTypes\n                };\n        }\n    }\n    generateAuditDetails(logs, type) {\n        switch(type){\n            case 'compliance':\n                return [\n                    {\n                        check: 'QR Code Generation Process',\n                        status: 'Passed',\n                        score: 100,\n                        details: 'All QR codes generated with proper authorization'\n                    },\n                    {\n                        check: 'Approval Workflow',\n                        status: 'Passed',\n                        score: 98,\n                        details: 'All requests follow proper approval chain'\n                    },\n                    {\n                        check: 'KYC Verification Process',\n                        status: 'Warning',\n                        score: 95,\n                        details: '2 KYC requests pending review beyond 48 hours'\n                    },\n                    {\n                        check: 'Data Retention Policy',\n                        status: 'Passed',\n                        score: 100,\n                        details: 'All audit logs properly maintained'\n                    },\n                    {\n                        check: 'User Access Controls',\n                        status: 'Passed',\n                        score: 99,\n                        details: 'Role-based access properly enforced'\n                    }\n                ];\n            case 'security':\n                return [\n                    {\n                        event: 'Authentication Events',\n                        count: logs.filter((log)=>log.actionType.includes('LOGIN')).length,\n                        severity: 'Info'\n                    },\n                    {\n                        event: 'QR Code Blocks',\n                        count: logs.filter((log)=>log.actionType === 'QR_BLOCKED').length,\n                        severity: 'Medium'\n                    },\n                    {\n                        event: 'Failed Approvals',\n                        count: logs.filter((log)=>log.actionType === 'REQUEST_REJECTED').length,\n                        severity: 'Low'\n                    },\n                    {\n                        event: 'System Access',\n                        count: logs.filter((log)=>log.actionType.includes('SYSTEM')).length,\n                        severity: 'Info'\n                    }\n                ];\n            case 'performance':\n                return [\n                    {\n                        metric: 'QR Generation Speed',\n                        value: '0.8 seconds',\n                        target: '< 2 seconds',\n                        status: 'Excellent'\n                    },\n                    {\n                        metric: 'Request Processing Time',\n                        value: '2.3 hours',\n                        target: '< 4 hours',\n                        status: 'Good'\n                    },\n                    {\n                        metric: 'System Response Time',\n                        value: '1.2 seconds',\n                        target: '< 3 seconds',\n                        status: 'Excellent'\n                    },\n                    {\n                        metric: 'Database Query Performance',\n                        value: '0.3 seconds',\n                        target: '< 1 second',\n                        status: 'Excellent'\n                    }\n                ];\n            case 'user_activity':\n                return this.getUserActivityBreakdown(logs);\n            default:\n                return [];\n        }\n    }\n    generateAuditRecommendations(logs, type) {\n        switch(type){\n            case 'compliance':\n                return [\n                    'Implement automated KYC review reminders for requests pending over 24 hours',\n                    'Consider adding additional approval checkpoints for high-value QR requests',\n                    'Review and update data retention policies quarterly'\n                ];\n            case 'security':\n                return [\n                    'Enable two-factor authentication for all administrative users',\n                    'Implement automated security monitoring for unusual access patterns',\n                    'Regular security training for all users recommended'\n                ];\n            case 'performance':\n                return [\n                    'System performance is excellent, maintain current infrastructure',\n                    'Consider load balancing for future scaling',\n                    'Monitor database performance during peak usage periods'\n                ];\n            case 'user_activity':\n                return [\n                    'Provide additional training for users with low activity levels',\n                    'Recognize high-performing users in monthly reviews',\n                    'Consider workflow optimization for frequently performed actions'\n                ];\n            default:\n                return [];\n        }\n    }\n    getMostActiveUser(logs) {\n        var _Object_entries_sort_;\n        const userCounts = logs.reduce((acc, log)=>{\n            acc[log.actorUserId] = (acc[log.actorUserId] || 0) + 1;\n            return acc;\n        }, {});\n        const mostActiveUserId = (_Object_entries_sort_ = Object.entries(userCounts).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return b - a;\n        })[0]) === null || _Object_entries_sort_ === void 0 ? void 0 : _Object_entries_sort_[0];\n        const user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.find((u)=>u.id === mostActiveUserId);\n        return user ? user.name : 'Unknown';\n    }\n    getMostCommonAction(logs) {\n        var _Object_entries_sort_;\n        const actionCounts = logs.reduce((acc, log)=>{\n            acc[log.actionType] = (acc[log.actionType] || 0) + 1;\n            return acc;\n        }, {});\n        return ((_Object_entries_sort_ = Object.entries(actionCounts).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return b - a;\n        })[0]) === null || _Object_entries_sort_ === void 0 ? void 0 : _Object_entries_sort_[0]) || 'None';\n    }\n    getUserActivityBreakdown(logs) {\n        const userActivity = logs.reduce((acc, log)=>{\n            if (!acc[log.actorUserId]) {\n                const user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockUsers.find((u)=>u.id === log.actorUserId);\n                acc[log.actorUserId] = {\n                    userId: log.actorUserId,\n                    userName: (user === null || user === void 0 ? void 0 : user.name) || 'Unknown',\n                    userRole: (user === null || user === void 0 ? void 0 : user.role) || 'Unknown',\n                    actions: []\n                };\n            }\n            acc[log.actorUserId].actions.push(log);\n            return acc;\n        }, {});\n        return Object.values(userActivity).map((user)=>{\n            var _user_actions_;\n            return {\n                ...user,\n                totalActions: user.actions.length,\n                lastActivity: (_user_actions_ = user.actions[0]) === null || _user_actions_ === void 0 ? void 0 : _user_actions_.timestamp,\n                actionBreakdown: user.actions.reduce((acc, action)=>{\n                    acc[action.actionType] = (acc[action.actionType] || 0) + 1;\n                    return acc;\n                }, {})\n            };\n        });\n    }\n    // Region Performance\n    async getRegionPerformance(regionName) {\n        const regions = [\n            {\n                name: 'Central Region',\n                branches: [\n                    'Downtown Branch',\n                    'Midtown Branch'\n                ],\n                totalQRs: 145,\n                issued: 98\n            },\n            {\n                name: 'North Region',\n                branches: [\n                    'Uptown Branch',\n                    'Northside Branch'\n                ],\n                totalQRs: 132,\n                issued: 87\n            },\n            {\n                name: 'West Region',\n                branches: [\n                    'Westside Branch',\n                    'West End Branch'\n                ],\n                totalQRs: 98,\n                issued: 65\n            }\n        ];\n        if (regionName) {\n            return regions.filter((r)=>r.name === regionName);\n        }\n        return regions;\n    }\n    // Seller Performance\n    async getSellerPerformance(sellerName) {\n        const sellers = [\n            {\n                name: 'Mike Sales',\n                userId: 'sales_001',\n                branch: 'Downtown Branch',\n                totalSales: 23,\n                thisMonth: 8,\n                lastMonth: 15,\n                avgPerWeek: 5.8,\n                topMerchants: [\n                    'Shop A',\n                    'Store B',\n                    'Market C'\n                ]\n            },\n            {\n                name: 'Sarah Johnson',\n                userId: 'sales_002',\n                branch: 'Uptown Branch',\n                totalSales: 19,\n                thisMonth: 6,\n                lastMonth: 13,\n                avgPerWeek: 4.8,\n                topMerchants: [\n                    'Cafe X',\n                    'Restaurant Y',\n                    'Shop Z'\n                ]\n            },\n            {\n                name: 'David Chen',\n                userId: 'sales_003',\n                branch: 'Westside Branch',\n                totalSales: 16,\n                thisMonth: 5,\n                lastMonth: 11,\n                avgPerWeek: 4.0,\n                topMerchants: [\n                    'Store 1',\n                    'Shop 2',\n                    'Market 3'\n                ]\n            }\n        ];\n        if (sellerName) {\n            return sellers.filter((s)=>s.name === sellerName);\n        }\n        return sellers;\n    }\n    // Update QR Code\n    async updateQRCode(qrId, updates) {\n        const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n        if (qr) {\n            if (updates.merchantId) qr.merchantId = updates.merchantId;\n            if (updates.terminalId) qr.terminalId = updates.terminalId;\n            if (updates.notes) qr.notes = updates.notes;\n            qr.updatedAt = new Date().toISOString();\n        }\n        this.logAction('QR_UPDATED', 'qr_code', {\n            qrId,\n            updates\n        });\n    }\n    async updateQRStatus(qrId, status, reason) {\n        const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n        if (qr) {\n            const oldStatus = qr.status;\n            qr.status = status;\n            qr.updatedAt = new Date().toISOString();\n            // Add status change to notes\n            const statusChangeNote = \"Status changed from \".concat(oldStatus, \" to \").concat(status, \". Reason: \").concat(reason);\n            qr.notes = qr.notes ? \"\".concat(qr.notes, \"\\n\").concat(statusChangeNote) : statusChangeNote;\n        }\n        this.logAction('QR_STATUS_UPDATED', 'qr_code', {\n            qrId,\n            oldStatus: qr === null || qr === void 0 ? void 0 : qr.status,\n            newStatus: status,\n            reason\n        });\n    }\n    async blockQRCode(qrId, reason) {\n        const qr = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockQRCodes.find((q)=>q.id === qrId);\n        if (qr) {\n            var _this_currentUser;\n            qr.status = 'blocked';\n            qr.blockedReason = reason;\n            qr.blockedAt = new Date().toISOString();\n            qr.blockedBy = ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || 'system';\n            qr.updatedAt = new Date().toISOString();\n        }\n        this.logAction('QR_BLOCKED', 'qr_code', {\n            qrId,\n            reason\n        });\n    }\n    logAction(action, entity, payload) {\n        var _this_currentUser;\n        const log = {\n            id: \"log_\".concat(Date.now(), \"_\").concat(Math.random()),\n            actorUserId: ((_this_currentUser = this.currentUser) === null || _this_currentUser === void 0 ? void 0 : _this_currentUser.id) || 'system',\n            actionType: action,\n            targetEntity: entity,\n            payload,\n            timestamp: new Date().toISOString()\n        };\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditLogs.unshift(log);\n    }\n    constructor(){\n        this.currentUser = null;\n        this.thresholdRequests = [];\n        this.merchantRequests = [];\n        this.merchants = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockMerchants\n        ];\n        this.kycRequests = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockKYCRequests\n        ];\n        this.auditItems = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditItems\n        ];\n        this.auditChecklists = [\n            ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockAuditChecklists\n        ];\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eVQsU0FBUyxHQUFHLElBQUlwVixPQUFPTyxXQUFXO1lBQ3JDb0IsR0FBRzBULFNBQVMsR0FBRywwQkFBSSxDQUFDcFgsV0FBVyxjQUFoQiwwREFBa0I4QixFQUFFLEtBQUk7WUFDdkM0QixHQUFHbEIsU0FBUyxHQUFHLElBQUlULE9BQU9PLFdBQVc7UUFDdkM7UUFFQSxJQUFJLENBQUNHLFNBQVMsQ0FBQyxjQUFjLFdBQVc7WUFBRXlCO1lBQU1nQjtRQUFPO0lBQ3pEO0lBRVF6QyxVQUFVdVQsTUFBYyxFQUFFcUIsTUFBYyxFQUFFM1EsT0FBWSxFQUFRO1lBR3JEO1FBRmYsTUFBTUQsTUFBZ0I7WUFDcEIzRSxJQUFJLE9BQXFCYyxPQUFkYixLQUFLQyxHQUFHLElBQUcsS0FBaUIsT0FBZFksS0FBS0UsTUFBTTtZQUNwQ2dNLGFBQWEsMEJBQUksQ0FBQzlPLFdBQVcsY0FBaEIsMERBQWtCOEIsRUFBRSxLQUFJO1lBQ3JDK00sWUFBWW1IO1lBQ1pyUCxjQUFjMFE7WUFDZDNRO1lBQ0E2QixXQUFXLElBQUl4RyxPQUFPTyxXQUFXO1FBQ25DO1FBRUFwRCxvREFBYUEsQ0FBQ29ZLE9BQU8sQ0FBQzdRO0lBQ3hCOzthQTkwQ1F6RyxjQUEyQjthQUMzQnNNLG9CQUF3QyxFQUFFO2FBQzFDcUIsbUJBQXNDLEVBQUU7YUFDeENSLFlBQXdCO2VBQUk1TixvREFBYUE7U0FBQzthQUMxQ29JLGNBQTRCO2VBQUl2SSxzREFBZUE7U0FBQzthQUNoRHdRLGFBQTBCO2VBQUl2USxxREFBY0E7U0FBQzthQUM3QzZSLGtCQUFvQztlQUFJNVIsMERBQW1CQTtTQUFDOztBQXkwQ3RFO0FBRU8sTUFBTWlZLGFBQWEsSUFBSS9YLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQUFVRUNcXERlc2t0b3BcXHNlY3FyX2Zyb250ZW5kXFxzZXJ2aWNlc1xcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVzZXIsIFFSQ29kZSwgQWxsb2NhdGlvblJlcXVlc3QsIERhc2hib2FyZFN0YXRzLCBSZXR1cm5SZWNvcmQsIEF1ZGl0TG9nIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgbW9ja1VzZXJzLCBtb2NrUVJDb2RlcywgbW9ja0FsbG9jYXRpb25SZXF1ZXN0cywgbW9ja0F1ZGl0TG9ncywgbW9ja0JyYW5jaGVzLCBtb2NrS1lDUmVxdWVzdHMsIG1vY2tBdWRpdEl0ZW1zLCBtb2NrQXVkaXRDaGVja2xpc3RzIH0gZnJvbSAnLi9tb2NrRGF0YSc7XG5pbXBvcnQgdHlwZSB7IEJyYW5jaCwgQnJhbmNoSW52ZW50b3J5LCBUaHJlc2hvbGRSZXF1ZXN0LCBNZXJjaGFudCwgTWVyY2hhbnRSZXF1ZXN0LCBLWUNSZXF1ZXN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBBdWRpdEl0ZW0sIEF1ZGl0Q2hlY2tsaXN0LCBBdWRpdFNjb3JlY2FyZCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG1vY2tNZXJjaGFudHMgfSBmcm9tICcuL21vY2tEYXRhJztcblxuY2xhc3MgQXBpU2VydmljZSB7XG4gIHByaXZhdGUgY3VycmVudFVzZXI6IFVzZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0aHJlc2hvbGRSZXF1ZXN0czogVGhyZXNob2xkUmVxdWVzdFtdID0gW107XG4gIHByaXZhdGUgbWVyY2hhbnRSZXF1ZXN0czogTWVyY2hhbnRSZXF1ZXN0W10gPSBbXTtcbiAgcHJpdmF0ZSBtZXJjaGFudHM6IE1lcmNoYW50W10gPSBbLi4ubW9ja01lcmNoYW50c107XG4gIHByaXZhdGUga3ljUmVxdWVzdHM6IEtZQ1JlcXVlc3RbXSA9IFsuLi5tb2NrS1lDUmVxdWVzdHNdO1xuICBwcml2YXRlIGF1ZGl0SXRlbXM6IEF1ZGl0SXRlbVtdID0gWy4uLm1vY2tBdWRpdEl0ZW1zXTtcbiAgcHJpdmF0ZSBhdWRpdENoZWNrbGlzdHM6IEF1ZGl0Q2hlY2tsaXN0W10gPSBbLi4ubW9ja0F1ZGl0Q2hlY2tsaXN0c107XG5cbiAgYXN5bmMgbG9naW4odXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xuICAgIC8vIE1vY2sgYXV0aGVudGljYXRpb25cbiAgICBjb25zdCB1c2VyID0gbW9ja1VzZXJzLmZpbmQodSA9PiB1LnVzZXJuYW1lID09PSB1c2VybmFtZSk7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY3JlZGVudGlhbHMnKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VXNlciA9IHVzZXI7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VyJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG5cbiAgZ2V0Q3VycmVudFVzZXIoKTogVXNlciB8IG51bGwge1xuICAgIGlmICghdGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2N1cnJlbnRVc2VyJyk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuICB9XG5cbiAgbG9nb3V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVFSVmFsdWUobWV0YWRhdGE6IGFueSwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgcGFydHMgPSBbbWV0YWRhdGEuYmFua05hbWUsIG1ldGFkYXRhLm1lcmNoYW50TmFtZSwgbWV0YWRhdGEubWVyY2hhbnRJZF07XG4gICAgXG4gICAgaWYgKG1ldGFkYXRhLnRlcm1pbmFsSWQpIHtcbiAgICAgIHBhcnRzLnB1c2gobWV0YWRhdGEudGVybWluYWxJZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlUVJDb2Rlcyhjb3VudDogbnVtYmVyLCB0eXBlOiAnc3RhdGljJyB8ICdkeW5hbWljJywgbWV0YWRhdGE/OiB7XG4gICAgYmFua05hbWU/OiBzdHJpbmc7XG4gICAgbWVyY2hhbnROYW1lPzogc3RyaW5nO1xuICAgIG1lcmNoYW50SWQ/OiBzdHJpbmc7XG4gICAgdGVybWluYWxJZD86IHN0cmluZztcbiAgfSk6IFByb21pc2U8UVJDb2RlW10+IHtcbiAgICAvLyBWYWxpZGF0ZSBtYW5kYXRvcnkgZmllbGRzXG4gICAgaWYgKCFtZXRhZGF0YT8uYmFua05hbWUgfHwgIW1ldGFkYXRhPy5tZXJjaGFudE5hbWUgfHwgIW1ldGFkYXRhPy5tZXJjaGFudElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhbmsgTmFtZSwgTWVyY2hhbnQgTmFtZSwgYW5kIE1lcmNoYW50IElEIGFyZSByZXF1aXJlZCBmaWVsZHMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTW9jayBRUiBnZW5lcmF0aW9uXG4gICAgY29uc3QgbmV3UVJzOiBRUkNvZGVbXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiAoe1xuICAgICAgaWQ6IGBxcl9nZW5fJHtEYXRlLm5vdygpfV8ke2l9YCxcbiAgICAgIHFyVmFsdWU6IHRoaXMuZ2VuZXJhdGVRUlZhbHVlKG1ldGFkYXRhLCBpKSxcbiAgICAgIHFyVHlwZTogdHlwZSxcbiAgICAgIGdlbmVyYXRpb25Tb3VyY2U6ICdzeXN0ZW0nLFxuICAgICAgc3RhdHVzOiAndW5hbGxvY2F0ZWQnLFxuICAgICAgYmFua05hbWU6IG1ldGFkYXRhPy5iYW5rTmFtZSxcbiAgICAgIG1lcmNoYW50TmFtZTogbWV0YWRhdGE/Lm1lcmNoYW50TmFtZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdGVybWluYWxJZDogbWV0YWRhdGE/LnRlcm1pbmFsSWQgfHwgdW5kZWZpbmVkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KSk7XG4gICAgXG4gICAgbW9ja1FSQ29kZXMucHVzaCguLi5uZXdRUnMpO1xuICAgIHRoaXMubG9nQWN0aW9uKCdRUl9HRU5FUkFURUQnLCAncXJfY29kZScsIHsgY291bnQsIHR5cGUgfSk7XG4gICAgcmV0dXJuIG5ld1FScztcbiAgfVxuXG4gIGFzeW5jIHVwbG9hZFFSQ29kZXMoZmlsZTogRmlsZSk6IFByb21pc2U8UVJDb2RlW10+IHtcbiAgICAvLyBNb2NrIGZpbGUgdXBsb2FkIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDEwO1xuICAgIGNvbnN0IG5ld1FSczogUVJDb2RlW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb3VudCB9LCAoXywgaSkgPT4gKHtcbiAgICAgIGlkOiBgcXJfdXBsb2FkXyR7RGF0ZS5ub3coKX1fJHtpfWAsXG4gICAgICBxclZhbHVlOiBgVVBMJHtEYXRlLm5vdygpfSR7U3RyaW5nKGkpLnBhZFN0YXJ0KDMsICcwJyl9YCxcbiAgICAgIHFyVHlwZTogJ3N0YXRpYycsXG4gICAgICBnZW5lcmF0aW9uU291cmNlOiAndXBsb2FkJyxcbiAgICAgIG1lcmNoYW50QmFua0FjY291bnQ6IG1ldGFkYXRhPy5tZXJjaGFudEJhbmtBY2NvdW50LFxuICAgICAgdXBsb2FkRmlsZUlkOiBgZmlsZV8ke0RhdGUubm93KCl9YCxcbiAgICAgIGNyZWF0ZWRCeTogdGhpcy5jdXJyZW50VXNlcj8uaWQgfHwgJzEnLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH0pKTtcbiAgICBcbiAgICBtb2NrUVJDb2Rlcy5wdXNoKC4uLm5ld1FScyk7XG4gICAgdGhpcy5sb2dBY3Rpb24oJ1FSX1VQTE9BREVEJywgJ3FyX2NvZGUnLCB7IGZpbGVuYW1lOiBmaWxlLm5hbWUsIGNvdW50IH0pO1xuICAgIHJldHVybiBuZXdRUnM7XG4gIH1cblxuICBhc3luYyBnZXRRUkNvZGVzKGZpbHRlcnM/OiB7IHN0YXR1cz86IHN0cmluZzsgYnJhbmNoSWQ/OiBzdHJpbmcgfSk6IFByb21pc2U8UVJDb2RlW10+IHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICBsZXQgcXJzID0gWy4uLm1vY2tRUkNvZGVzXTtcbiAgICBcbiAgICBpZiAoZmlsdGVycz8uc3RhdHVzKSB7XG4gICAgICBxcnMgPSBxcnMuZmlsdGVyKHFyID0+IHFyLnN0YXR1cyA9PT0gZmlsdGVycy5zdGF0dXMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycz8uYnJhbmNoSWQpIHtcbiAgICAgIHFycyA9IHFycy5maWx0ZXIocXIgPT4gcXIuYWxsb2NhdGVkQnJhbmNoSWQgPT09IGZpbHRlcnMuYnJhbmNoSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igc2FsZXMgdXNlcnMsIHNob3cgb25seSB0aGVpciBRUnNcbiAgICBpZiAoY3VycmVudFVzZXI/LnJvbGUgPT09ICdTQUxFU19VU0VSJykge1xuICAgICAgcXJzID0gcXJzLmZpbHRlcihxciA9PiBxci5hbGxvY2F0ZWRUb1VzZXJJZCA9PT0gY3VycmVudFVzZXIuaWQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcXJzO1xuICB9XG5cbiAgYXN5bmMgYWxsb2NhdGVRUnNUb0JyYW5jaChxcklkczogc3RyaW5nW10sIGJyYW5jaElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBxcklkcy5mb3JFYWNoKHFySWQgPT4ge1xuICAgICAgY29uc3QgcXIgPSBtb2NrUVJDb2Rlcy5maW5kKHEgPT4gcS5pZCA9PT0gcXJJZCk7XG4gICAgICBpZiAocXIpIHtcbiAgICAgICAgcXIuc3RhdHVzID0gJ2FsbG9jYXRlZCc7XG4gICAgICAgIHFyLmFsbG9jYXRlZEJyYW5jaElkID0gYnJhbmNoSWQ7XG4gICAgICAgIHFyLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignUVJfQUxMT0NBVEVEJywgJ3FyX2NvZGUnLCB7IHFySWRzLCBicmFuY2hJZCB9KTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUFsbG9jYXRpb25SZXF1ZXN0KGRhdGE6IFBhcnRpYWw8QWxsb2NhdGlvblJlcXVlc3Q+KTogUHJvbWlzZTxBbGxvY2F0aW9uUmVxdWVzdD4ge1xuICAgIGNvbnN0IHJlcXVlc3Q6IEFsbG9jYXRpb25SZXF1ZXN0ID0ge1xuICAgICAgaWQ6IGByZXFfJHtEYXRlLm5vdygpfWAsXG4gICAgICByZXF1ZXN0TnVtYmVyOiBgUkVRJHtTdHJpbmcobW9ja0FsbG9jYXRpb25SZXF1ZXN0cy5sZW5ndGggKyAxKS5wYWRTdGFydCgzLCAnMCcpfWAsXG4gICAgICBicmFuY2hJZDogZGF0YS5icmFuY2hJZCEsXG4gICAgICBpbml0aWF0b3JVc2VySWQ6IHRoaXMuY3VycmVudFVzZXI/LmlkIHx8ICcxJyxcbiAgICAgIHJlcXVlc3RlZFFyQ291bnQ6IGRhdGEucmVxdWVzdGVkUXJDb3VudCEsXG4gICAgICByZXF1ZXN0ZWRGb3I6IGRhdGEucmVxdWVzdGVkRm9yISxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgbm90ZXM6IGRhdGEubm90ZXMgfHwgJycsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgbW9ja0FsbG9jYXRpb25SZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHRoaXMubG9nQWN0aW9uKCdSRVFVRVNUX0NSRUFURUQnLCAnYWxsb2NhdGlvbl9yZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICBhc3luYyBhcHByb3ZlUmVxdWVzdChyZXF1ZXN0SWQ6IHN0cmluZywgbm90ZXM/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbW9ja0FsbG9jYXRpb25SZXF1ZXN0cy5maW5kKHIgPT4gci5pZCA9PT0gcmVxdWVzdElkKTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnYXBwcm92ZWQnO1xuICAgICAgcmVxdWVzdC5hcHByb3ZlclVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXI/LmlkO1xuICAgICAgcmVxdWVzdC5hcHByb3ZlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgaWYgKG5vdGVzKSByZXF1ZXN0Lm5vdGVzICs9IGBcXG5BcHByb3ZhbCBub3RlczogJHtub3Rlc31gO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignUkVRVUVTVF9BUFBST1ZFRCcsICdhbGxvY2F0aW9uX3JlcXVlc3QnLCB7IHJlcXVlc3RJZCwgbm90ZXMgfSk7XG4gIH1cblxuICBhc3luYyByZWplY3RSZXF1ZXN0KHJlcXVlc3RJZDogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBtb2NrQWxsb2NhdGlvblJlcXVlc3RzLmZpbmQociA9PiByLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICByZXF1ZXN0LmFwcHJvdmVyVXNlcklkID0gdGhpcy5jdXJyZW50VXNlcj8uaWQ7XG4gICAgICByZXF1ZXN0Lm5vdGVzICs9IGBcXG5SZWplY3Rpb24gcmVhc29uOiAke3JlYXNvbn1gO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignUkVRVUVTVF9SRUpFQ1RFRCcsICdhbGxvY2F0aW9uX3JlcXVlc3QnLCB7IHJlcXVlc3RJZCwgcmVhc29uIH0pO1xuICB9XG5cbiAgYXN5bmMgcmV0dXJuUmVxdWVzdEZvckNvcnJlY3Rpb24ocmVxdWVzdElkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG1vY2tBbGxvY2F0aW9uUmVxdWVzdHMuZmluZChyID0+IHIuaWQgPT09IHJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgcmVxdWVzdC5hcHByb3ZlclVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXI/LmlkO1xuICAgICAgcmVxdWVzdC5ub3RlcyArPSBgXFxuUmV0dXJuZWQgZm9yIGNvcnJlY3Rpb246ICR7cmVhc29ufWA7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdSRVFVRVNUX1JFVFVSTkVEX0ZPUl9DT1JSRUNUSU9OJywgJ2FsbG9jYXRpb25fcmVxdWVzdCcsIHsgcmVxdWVzdElkLCByZWFzb24gfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlQWxsb2NhdGlvblJlcXVlc3QocmVxdWVzdElkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8QWxsb2NhdGlvblJlcXVlc3Q+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG1vY2tBbGxvY2F0aW9uUmVxdWVzdHMuZmluZChyID0+IHIuaWQgPT09IHJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVxdWVzdCwgdXBkYXRlcyk7XG4gICAgICByZXF1ZXN0LnN0YXR1cyA9ICdwZW5kaW5nJzsgLy8gUmVzZXQgdG8gcGVuZGluZyB3aGVuIGVkaXRlZFxuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignUkVRVUVTVF9VUERBVEVEJywgJ2FsbG9jYXRpb25fcmVxdWVzdCcsIHsgcmVxdWVzdElkLCB1cGRhdGVzIH0pO1xuICB9XG4gIGFzeW5jIGdldEFsbG9jYXRpb25SZXF1ZXN0cyhicmFuY2hJZD86IHN0cmluZyk6IFByb21pc2U8QWxsb2NhdGlvblJlcXVlc3RbXT4ge1xuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gdGhpcy5nZXRDdXJyZW50VXNlcigpO1xuICAgIGxldCByZXF1ZXN0cyA9IFsuLi5tb2NrQWxsb2NhdGlvblJlcXVlc3RzXTtcbiAgICBcbiAgICBpZiAoYnJhbmNoSWQpIHtcbiAgICAgIHJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHIgPT4gci5icmFuY2hJZCA9PT0gYnJhbmNoSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3Igc2FsZXMgdXNlcnMsIHNob3cgb25seSB0aGVpciByZXF1ZXN0c1xuICAgIGlmIChjdXJyZW50VXNlcj8ucm9sZSA9PT0gJ1NBTEVTX1VTRVInKSB7XG4gICAgICByZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcihyID0+IHIuaW5pdGlhdG9yVXNlcklkID09PSBjdXJyZW50VXNlci5pZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXF1ZXN0cztcbiAgfVxuXG4gIGFzeW5jIGlzc3VlUVJUb01lcmNoYW50KHFySWQ6IHN0cmluZywgbWVyY2hhbnREYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBxciA9IG1vY2tRUkNvZGVzLmZpbmQocSA9PiBxLmlkID09PSBxcklkKTtcbiAgICBpZiAocXIpIHtcbiAgICAgIHFyLnN0YXR1cyA9ICdpc3N1ZWQnO1xuICAgICAgcXIuaXNzdWVkVG9NZXJjaGFudElkID0gbWVyY2hhbnREYXRhLmlkO1xuICAgICAgcXIudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignUVJfSVNTVUVEJywgJ3FyX2NvZGUnLCB7IHFySWQsIG1lcmNoYW50RGF0YSB9KTtcbiAgfVxuXG4gIGFzeW5jIHJldHVyblFSKHFySWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcsIGNvbmRpdGlvbjogc3RyaW5nKTogUHJvbWlzZTxSZXR1cm5SZWNvcmQ+IHtcbiAgICBjb25zdCBxciA9IG1vY2tRUkNvZGVzLmZpbmQocSA9PiBxLmlkID09PSBxcklkKTtcbiAgICBpZiAocXIpIHtcbiAgICAgIHFyLnN0YXR1cyA9ICdyZXR1cm5lZCc7XG4gICAgICBxci51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJldHVyblJlY29yZDogUmV0dXJuUmVjb3JkID0ge1xuICAgICAgaWQ6IGByZXRfJHtEYXRlLm5vdygpfWAsXG4gICAgICBxcklkLFxuICAgICAgcmV0dXJuZWRCeVVzZXJJZDogdGhpcy5jdXJyZW50VXNlcj8uaWQgfHwgJzEnLFxuICAgICAgcmV0dXJuZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgcmVhc29uLFxuICAgICAgY29uZGl0aW9uLFxuICAgICAgc3RhdHVzOiAncGVuZGluZydcbiAgICB9O1xuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdRUl9SRVRVUk5FRCcsICdxcl9jb2RlJywgeyBxcklkLCByZWFzb24sIGNvbmRpdGlvbiB9KTtcbiAgICByZXR1cm4gcmV0dXJuUmVjb3JkO1xuICB9XG5cbiAgYXN5bmMgZ2V0RGFzaGJvYXJkU3RhdHMoYnJhbmNoSWQ/OiBzdHJpbmcpOiBQcm9taXNlPERhc2hib2FyZFN0YXRzPiB7XG4gICAgY29uc3QgcXJzID0gbW9ja1FSQ29kZXM7XG4gICAgY29uc3QgcmVxdWVzdHMgPSBtb2NrQWxsb2NhdGlvblJlcXVlc3RzO1xuICAgIGNvbnN0IHVzZXJzID0gbW9ja1VzZXJzO1xuICAgIGNvbnN0IGJyYW5jaGVzID0gbW9ja0JyYW5jaGVzO1xuICAgIFxuICAgIC8vIEZpbHRlciBkYXRhIGJ5IGJyYW5jaCBpZiBicmFuY2hJZCBpcyBwcm92aWRlZCAoZm9yIGJyYW5jaCBhcHByb3ZlcnMpXG4gICAgY29uc3QgZmlsdGVyZWRRUnMgPSBicmFuY2hJZCA/IHFycy5maWx0ZXIocSA9PiBxLmFsbG9jYXRlZEJyYW5jaElkID09PSBicmFuY2hJZCkgOiBxcnM7XG4gICAgY29uc3QgZmlsdGVyZWRSZXF1ZXN0cyA9IGJyYW5jaElkID8gcmVxdWVzdHMuZmlsdGVyKHIgPT4gci5icmFuY2hJZCA9PT0gYnJhbmNoSWQpIDogcmVxdWVzdHM7XG4gICAgY29uc3QgZmlsdGVyZWRVc2VycyA9IGJyYW5jaElkID8gdXNlcnMuZmlsdGVyKHUgPT4gdS5icmFuY2hJZCA9PT0gYnJhbmNoSWQpIDogdXNlcnM7XG4gICAgY29uc3QgZmlsdGVyZWRBY3Rpdml0eSA9IGJyYW5jaElkID8gbW9ja0F1ZGl0TG9ncy5maWx0ZXIobG9nID0+IHtcbiAgICAgIC8vIEZpbHRlciBhY3Rpdml0eSBieSBicmFuY2gtcmVsYXRlZCBhY3Rpb25zXG4gICAgICByZXR1cm4gbG9nLnBheWxvYWQ/LmJyYW5jaElkID09PSBicmFuY2hJZCB8fCBcbiAgICAgICAgICAgICAobG9nLnRhcmdldEVudGl0eSA9PT0gJ2FsbG9jYXRpb25fcmVxdWVzdCcgJiYgZmlsdGVyZWRSZXF1ZXN0cy5zb21lKHIgPT4gci5pZCA9PT0gbG9nLnBheWxvYWQ/LnJlcXVlc3RJZCkpO1xuICAgIH0pIDogbW9ja0F1ZGl0TG9ncztcbiAgICBcbiAgICAvLyBTeW5jIFFSIGNvZGVzIHdpdGggdXNlcnMgYW5kIGJyYW5jaGVzXG4gICAgdGhpcy5zeW5jUVJDb2Rlc1dpdGhVc2Vyc0FuZEJyYW5jaGVzKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGFjY3VyYXRlIGNvdW50cyBiYXNlZCBvbiByb2xlIGFuZCB1c2VyIGNvbnRleHRcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICBsZXQgdG90YWxRUnMsIHVuYWxsb2NhdGVkLCBhbGxvY2F0ZWQsIGlzc3VlZCwgcmV0dXJuZWQsIGJsb2NrZWQ7XG4gICAgXG4gICAgaWYgKGJyYW5jaElkKSB7XG4gICAgICAvLyBGb3IgYnJhbmNoLXNwZWNpZmljIHJvbGVzIChicmFuY2ggbWFuYWdlcnMsIGFwcHJvdmVycywgc2FsZXMgdXNlcnMpXG4gICAgICB0b3RhbFFScyA9IGZpbHRlcmVkUVJzLmxlbmd0aDtcbiAgICAgIHVuYWxsb2NhdGVkID0gMDsgLy8gQnJhbmNoIHVzZXJzIGRvbid0IHNlZSB1bmFsbG9jYXRlZCBRUnNcbiAgICAgIGFsbG9jYXRlZCA9IGZpbHRlcmVkUVJzLmZpbHRlcihxID0+IHEuc3RhdHVzID09PSAnYWxsb2NhdGVkJykubGVuZ3RoO1xuICAgICAgaXNzdWVkID0gZmlsdGVyZWRRUnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGg7XG4gICAgICByZXR1cm5lZCA9IGZpbHRlcmVkUVJzLmZpbHRlcihxID0+IHEuc3RhdHVzID09PSAncmV0dXJuZWQnKS5sZW5ndGg7XG4gICAgICBibG9ja2VkID0gZmlsdGVyZWRRUnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdibG9ja2VkJykubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBGb3Igc2FsZXMgdXNlcnMsIGZ1cnRoZXIgZmlsdGVyIHRvIHNob3cgb25seSB0aGVpciBpc3N1ZWQgUVJzXG4gICAgICBpZiAoY3VycmVudFVzZXI/LnJvbGUgPT09ICdTQUxFU19VU0VSJykge1xuICAgICAgICBjb25zdCB1c2VySXNzdWVkUVJzID0gZmlsdGVyZWRRUnMuZmlsdGVyKHEgPT4gcS5hbGxvY2F0ZWRUb1VzZXJJZCA9PT0gY3VycmVudFVzZXIuaWQpO1xuICAgICAgICB0b3RhbFFScyA9IHVzZXJJc3N1ZWRRUnMubGVuZ3RoO1xuICAgICAgICBhbGxvY2F0ZWQgPSB1c2VySXNzdWVkUVJzLmZpbHRlcihxID0+IHEuc3RhdHVzID09PSAnYWxsb2NhdGVkJykubGVuZ3RoO1xuICAgICAgICBpc3N1ZWQgPSB1c2VySXNzdWVkUVJzLmZpbHRlcihxID0+IHEuc3RhdHVzID09PSAnaXNzdWVkJykubGVuZ3RoO1xuICAgICAgICByZXR1cm5lZCA9IHVzZXJJc3N1ZWRRUnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdyZXR1cm5lZCcpLmxlbmd0aDtcbiAgICAgICAgYmxvY2tlZCA9IHVzZXJJc3N1ZWRRUnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdibG9ja2VkJykubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igc3lzdGVtIGFkbWluLCBzaG93IHN5c3RlbS13aWRlIGRhdGFcbiAgICAgIHRvdGFsUVJzID0gcXJzLmxlbmd0aDtcbiAgICAgIHVuYWxsb2NhdGVkID0gcXJzLmZpbHRlcihxID0+IHEuc3RhdHVzID09PSAndW5hbGxvY2F0ZWQnKS5sZW5ndGg7XG4gICAgICBhbGxvY2F0ZWQgPSBxcnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdhbGxvY2F0ZWQnKS5sZW5ndGg7XG4gICAgICBpc3N1ZWQgPSBxcnMuZmlsdGVyKHEgPT4gcS5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGg7XG4gICAgICByZXR1cm5lZCA9IHFycy5maWx0ZXIocSA9PiBxLnN0YXR1cyA9PT0gJ3JldHVybmVkJykubGVuZ3RoO1xuICAgICAgYmxvY2tlZCA9IHFycy5maWx0ZXIocSA9PiBxLnN0YXR1cyA9PT0gJ2Jsb2NrZWQnKS5sZW5ndGg7XG4gICAgfVxuICAgIFxuICAgIC8vIEJyYW5jaCBhcHByb3ZlciBzcGVjaWZpYyBzdGF0c1xuICAgIGNvbnN0IHBlbmRpbmdBcHByb3ZhbHMgPSBmaWx0ZXJlZFJlcXVlc3RzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncGVuZGluZycpLmxlbmd0aDtcbiAgICBjb25zdCBhcHByb3ZlZFJlcXVlc3RzID0gZmlsdGVyZWRSZXF1ZXN0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2FwcHJvdmVkJykubGVuZ3RoO1xuICAgIGNvbnN0IHJlamVjdGVkUmVxdWVzdHMgPSBmaWx0ZXJlZFJlcXVlc3RzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncmVqZWN0ZWQnKS5sZW5ndGg7XG4gICAgY29uc3QgcmV0dXJuZWRGb3JDb3JyZWN0aW9uID0gZmlsdGVyZWRSZXF1ZXN0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ3BlbmRpbmcnICYmIHIubm90ZXM/LmluY2x1ZGVzKCdSZXR1cm5lZCBmb3IgY29ycmVjdGlvbicpKS5sZW5ndGg7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBlbmRpbmcgS1lDIHJlcXVlc3RzXG4gICAgY29uc3QgcGVuZGluZ0tZQyA9IGJyYW5jaElkID8gXG4gICAgICB0aGlzLmt5Y1JlcXVlc3RzLmZpbHRlcihreWMgPT4ga3ljLmJyYW5jaElkID09PSBicmFuY2hJZCAmJiBreWMuc3RhdHVzID09PSAncGVuZGluZycpLmxlbmd0aCA6XG4gICAgICB0aGlzLmt5Y1JlcXVlc3RzLmZpbHRlcihreWMgPT4ga3ljLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKS5sZW5ndGg7XG4gICAgXG4gICAgLy8gVG9wIHNlbGxlcnMgZmlsdGVyZWQgYnkgYnJhbmNoXG4gICAgY29uc3QgdG9wU2VsbGVycyA9IGJyYW5jaElkID8gXG4gICAgICB0aGlzLmdldFRvcFNlbGxlcnNCeUJyYW5jaChicmFuY2hJZCwgY3VycmVudFVzZXI/LnJvbGUgPT09ICdTQUxFU19VU0VSJyA/IGN1cnJlbnRVc2VyLmlkIDogdW5kZWZpbmVkKSA6IFxuICAgICAgdGhpcy5nZXRUb3BTZWxsZXJzR2xvYmFsKCk7XG4gICAgXG4gICAgLy8gVG9wIGJyYW5jaGVzIGFuZCByZWdpb25zIC0gY29uc2lzdGVudCB3aXRoIGFjdHVhbCBkYXRhXG4gICAgY29uc3QgdG9wQnJhbmNoZXMgPSBicmFuY2hJZCA/IFxuICAgICAgW3sgbmFtZTogYnJhbmNoZXMuZmluZChiID0+IGIuaWQgPT09IGJyYW5jaElkKT8ubmFtZSB8fCAnQ3VycmVudCBCcmFuY2gnLCBjb3VudDogaXNzdWVkIH1dIDpcbiAgICAgIFtcbiAgICAgICAgeyBuYW1lOiAnRG93bnRvd24gQnJhbmNoJywgY291bnQ6IHFycy5maWx0ZXIocSA9PiBxLmFsbG9jYXRlZEJyYW5jaElkID09PSAnMScgJiYgcS5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGggfSxcbiAgICAgICAgeyBuYW1lOiAnVXB0b3duIEJyYW5jaCcsIGNvdW50OiBxcnMuZmlsdGVyKHEgPT4gcS5hbGxvY2F0ZWRCcmFuY2hJZCA9PT0gJzInICYmIHEuc3RhdHVzID09PSAnaXNzdWVkJykubGVuZ3RoIH0sXG4gICAgICAgIHsgbmFtZTogJ1dlc3RzaWRlIEJyYW5jaCcsIGNvdW50OiBxcnMuZmlsdGVyKHEgPT4gcS5hbGxvY2F0ZWRCcmFuY2hJZCA9PT0gJzMnICYmIHEuc3RhdHVzID09PSAnaXNzdWVkJykubGVuZ3RoIH1cbiAgICAgIF07XG4gICAgXG4gICAgY29uc3QgdG9wUmVnaW9ucyA9ICFicmFuY2hJZCA/IFtcbiAgICAgIHsgbmFtZTogJ0NlbnRyYWwgUmVnaW9uJywgY291bnQ6IHFycy5maWx0ZXIocSA9PiBxLmFsbG9jYXRlZEJyYW5jaElkID09PSAnMScgJiYgcS5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGgsIGJyYW5jaENvdW50OiAxIH0sXG4gICAgICB7IG5hbWU6ICdOb3J0aCBSZWdpb24nLCBjb3VudDogcXJzLmZpbHRlcihxID0+IHEuYWxsb2NhdGVkQnJhbmNoSWQgPT09ICcyJyAmJiBxLnN0YXR1cyA9PT0gJ2lzc3VlZCcpLmxlbmd0aCwgYnJhbmNoQ291bnQ6IDEgfSxcbiAgICAgIHsgbmFtZTogJ1dlc3QgUmVnaW9uJywgY291bnQ6IHFycy5maWx0ZXIocSA9PiBxLmFsbG9jYXRlZEJyYW5jaElkID09PSAnMycgJiYgcS5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGgsIGJyYW5jaENvdW50OiAxIH1cbiAgICBdIDogdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFFScyxcbiAgICAgIHVuYWxsb2NhdGVkLFxuICAgICAgYWxsb2NhdGVkLFxuICAgICAgaXNzdWVkLFxuICAgICAgcmV0dXJuZWQsXG4gICAgICBibG9ja2VkLFxuICAgICAgcGVuZGluZ0FwcHJvdmFscyxcbiAgICAgIGFwcHJvdmVkUmVxdWVzdHMsXG4gICAgICByZWplY3RlZFJlcXVlc3RzLFxuICAgICAgcmV0dXJuZWRGb3JDb3JyZWN0aW9uLFxuICAgICAgdG9wQnJhbmNoZXMsXG4gICAgICB0b3BTZWxsZXJzLFxuICAgICAgdG9wUmVnaW9ucyxcbiAgICAgIHJlY2VudEFjdGl2aXR5OiBmaWx0ZXJlZEFjdGl2aXR5LnNsaWNlKC0xMCksXG4gICAgICBwZW5kaW5nS1lDXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gU3luYyBRUiBjb2RlcyB3aXRoIHVzZXJzIGFuZCBicmFuY2hlcyB0byBlbnN1cmUgZGF0YSBjb25zaXN0ZW5jeVxuICBwcml2YXRlIHN5bmNRUkNvZGVzV2l0aFVzZXJzQW5kQnJhbmNoZXMoKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIFFSIGNvZGVzIHRvIHJlZmxlY3QgY3VycmVudCBicmFuY2ggYW5kIHVzZXIgYXNzaWdubWVudHNcbiAgICBtb2NrUVJDb2Rlcy5mb3JFYWNoKHFyID0+IHtcbiAgICAgIC8vIEVuc3VyZSBhbGxvY2F0ZWQgUVJzIGhhdmUgdmFsaWQgYnJhbmNoIGFzc2lnbm1lbnRzXG4gICAgICBpZiAocXIuc3RhdHVzID09PSAnYWxsb2NhdGVkJyAmJiBxci5hbGxvY2F0ZWRCcmFuY2hJZCkge1xuICAgICAgICBjb25zdCBicmFuY2ggPSBtb2NrQnJhbmNoZXMuZmluZChiID0+IGIuaWQgPT09IHFyLmFsbG9jYXRlZEJyYW5jaElkKTtcbiAgICAgICAgaWYgKCFicmFuY2gpIHtcbiAgICAgICAgICAvLyBCcmFuY2ggbm8gbG9uZ2VyIGV4aXN0cywgcmVzZXQgUVIgdG8gdW5hbGxvY2F0ZWRcbiAgICAgICAgICBxci5zdGF0dXMgPSAndW5hbGxvY2F0ZWQnO1xuICAgICAgICAgIHFyLmFsbG9jYXRlZEJyYW5jaElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHFyLmFsbG9jYXRlZFRvVXNlcklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBpc3N1ZWQgUVJzIGhhdmUgdmFsaWQgdXNlciBhc3NpZ25tZW50c1xuICAgICAgaWYgKHFyLnN0YXR1cyA9PT0gJ2lzc3VlZCcgJiYgcXIuYWxsb2NhdGVkVG9Vc2VySWQpIHtcbiAgICAgICAgY29uc3QgdXNlciA9IG1vY2tVc2Vycy5maW5kKHUgPT4gdS5pZCA9PT0gcXIuYWxsb2NhdGVkVG9Vc2VySWQpO1xuICAgICAgICBpZiAoIXVzZXIgfHwgdXNlci5zdGF0dXMgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgICAgICAvLyBVc2VyIG5vIGxvbmdlciBleGlzdHMgb3IgaXMgaW5hY3RpdmUsIHJldHVybiBRUiB0byBhbGxvY2F0ZWQgc3RhdHVzXG4gICAgICAgICAgcXIuc3RhdHVzID0gJ2FsbG9jYXRlZCc7XG4gICAgICAgICAgcXIuYWxsb2NhdGVkVG9Vc2VySWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcXIuaXNzdWVkVG9NZXJjaGFudElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gTG9nIHN5bmMgYWN0aW9uXG4gICAgdGhpcy5sb2dBY3Rpb24oJ0RBVEFfU1lOQycsICdzeXN0ZW0nLCB7IFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBxckNvdW50OiBtb2NrUVJDb2Rlcy5sZW5ndGgsXG4gICAgICB1c2VyQ291bnQ6IG1vY2tVc2Vycy5sZW5ndGgsXG4gICAgICBicmFuY2hDb3VudDogbW9ja0JyYW5jaGVzLmxlbmd0aFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRUb3BTZWxsZXJzQnlCcmFuY2goYnJhbmNoSWQ6IHN0cmluZywgY3VycmVudFVzZXJJZD86IHN0cmluZyk6IHsgbmFtZTogc3RyaW5nOyBjb3VudDogbnVtYmVyOyBicmFuY2g/OiBzdHJpbmc7IHVzZXJJZD86IHN0cmluZyB9W10ge1xuICAgIGNvbnN0IGJyYW5jaE5hbWUgPSBtb2NrQnJhbmNoZXMuZmluZChiID0+IGIuaWQgPT09IGJyYW5jaElkKT8ubmFtZSB8fCAnVW5rbm93biBCcmFuY2gnO1xuICAgIGxldCBicmFuY2hVc2VycyA9IG1vY2tVc2Vycy5maWx0ZXIodSA9PiB1LmJyYW5jaElkID09PSBicmFuY2hJZCAmJiB1LnJvbGUgPT09ICdTQUxFU19VU0VSJyk7XG4gICAgXG4gICAgLy8gSWYgY3VycmVudFVzZXJJZCBpcyBwcm92aWRlZCAoZm9yIHNhbGVzIHVzZXJzKSwgc2hvdyBvbmx5IHRoZWlyIGRhdGFcbiAgICBpZiAoY3VycmVudFVzZXJJZCkge1xuICAgICAgYnJhbmNoVXNlcnMgPSBicmFuY2hVc2Vycy5maWx0ZXIodSA9PiB1LmlkID09PSBjdXJyZW50VXNlcklkKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGJyYW5jaFVzZXJzLm1hcCh1c2VyID0+IHtcbiAgICAgIGNvbnN0IGlzc3VlZENvdW50ID0gbW9ja1FSQ29kZXMuZmlsdGVyKHFyID0+IFxuICAgICAgICBxci5hbGxvY2F0ZWRCcmFuY2hJZCA9PT0gYnJhbmNoSWQgJiYgXG4gICAgICAgIHFyLnN0YXR1cyA9PT0gJ2lzc3VlZCcgJiYgXG4gICAgICAgIHFyLmFsbG9jYXRlZFRvVXNlcklkID09PSB1c2VyLmlkXG4gICAgICApLmxlbmd0aDtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgICBjb3VudDogaXNzdWVkQ291bnQsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoTmFtZSxcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkXG4gICAgICB9O1xuICAgIH0pLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VG9wU2VsbGVyc0dsb2JhbCgpOiB7IG5hbWU6IHN0cmluZzsgY291bnQ6IG51bWJlcjsgYnJhbmNoPzogc3RyaW5nOyB1c2VySWQ/OiBzdHJpbmcgfVtdIHtcbiAgICBjb25zdCBzYWxlc1VzZXJzID0gbW9ja1VzZXJzLmZpbHRlcih1ID0+IHUucm9sZSA9PT0gJ3NhbGVzX3VzZXInKTtcbiAgICBcbiAgICByZXR1cm4gc2FsZXNVc2Vycy5tYXAodXNlciA9PiB7XG4gICAgICBjb25zdCBicmFuY2hOYW1lID0gbW9ja0JyYW5jaGVzLmZpbmQoYiA9PiBiLmlkID09PSB1c2VyLmJyYW5jaElkKT8ubmFtZSB8fCAnVW5rbm93biBCcmFuY2gnO1xuICAgICAgY29uc3QgaXNzdWVkQ291bnQgPSBtb2NrUVJDb2Rlcy5maWx0ZXIocXIgPT4gXG4gICAgICAgIHFyLnN0YXR1cyA9PT0gJ2lzc3VlZCcgJiYgXG4gICAgICAgIHFyLmFsbG9jYXRlZFRvVXNlcklkID09PSB1c2VyLmlkXG4gICAgICApLmxlbmd0aDtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgICBjb3VudDogaXNzdWVkQ291bnQsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoTmFtZSxcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkXG4gICAgICB9O1xuICAgIH0pLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydERhdGEodHlwZTogJ3FyX2NvZGVzJyB8ICdhbGxvY2F0aW9ucycgfCAnaXNzdWFuY2VzJyk6IFByb21pc2U8QmxvYj4ge1xuICAgIC8vIE1vY2sgQ1NWIGV4cG9ydFxuICAgIGxldCBjc3ZEYXRhID0gJyc7XG4gICAgXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdxcl9jb2Rlcyc6XG4gICAgICAgIGNzdkRhdGEgPSAnSUQsUVIgVmFsdWUsVHlwZSxTdGF0dXMsQnJhbmNoLENyZWF0ZWQgQXRcXG4nO1xuICAgICAgICBtb2NrUVJDb2Rlcy5mb3JFYWNoKHFyID0+IHtcbiAgICAgICAgICBjc3ZEYXRhICs9IGAke3FyLmlkfSwke3FyLnFyVmFsdWV9LCR7cXIucXJUeXBlfSwke3FyLnN0YXR1c30sJHtxci5hbGxvY2F0ZWRCcmFuY2hJZCB8fCAnTi9BJ30sJHtxci5jcmVhdGVkQXR9XFxuYDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWxsb2NhdGlvbnMnOlxuICAgICAgICBjc3ZEYXRhID0gJ1JlcXVlc3QgSUQsQnJhbmNoLENvdW50LFN0YXR1cyxDcmVhdGVkIEF0XFxuJztcbiAgICAgICAgbW9ja0FsbG9jYXRpb25SZXF1ZXN0cy5mb3JFYWNoKHJlcSA9PiB7XG4gICAgICAgICAgY3N2RGF0YSArPSBgJHtyZXEucmVxdWVzdE51bWJlcn0sJHtyZXEuYnJhbmNoSWR9LCR7cmVxLnJlcXVlc3RlZFFyQ291bnR9LCR7cmVxLnN0YXR1c30sJHtyZXEuY3JlYXRlZEF0fVxcbmA7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICB9XG5cbiAgLy8gVXNlciBNYW5hZ2VtZW50XG4gIGFzeW5jIGNyZWF0ZVVzZXIodXNlckRhdGE6IFBhcnRpYWw8VXNlcj4pOiBQcm9taXNlPFVzZXI+IHtcbiAgICBjb25zdCBuZXdVc2VyOiBVc2VyID0ge1xuICAgICAgaWQ6IGB1c2VyXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lISxcbiAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCEsXG4gICAgICBuYW1lOiB1c2VyRGF0YS5uYW1lISxcbiAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUhLFxuICAgICAgYnJhbmNoSWQ6IHVzZXJEYXRhLmJyYW5jaElkLFxuICAgICAgcGhvbmU6IHVzZXJEYXRhLnBob25lISxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgbW9ja1VzZXJzLnB1c2gobmV3VXNlcik7XG4gICAgdGhpcy5sb2dBY3Rpb24oJ1VTRVJfQ1JFQVRFRCcsICd1c2VyJywgbmV3VXNlcik7XG4gICAgcmV0dXJuIG5ld1VzZXI7XG4gIH1cblxuICBhc3luYyBnZXRVc2VycygpOiBQcm9taXNlPFVzZXJbXT4ge1xuICAgIHJldHVybiBbLi4ubW9ja1VzZXJzXTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVVzZXIodXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VXNlcj4pOiBQcm9taXNlPFVzZXI+IHtcbiAgICBjb25zdCB1c2VySW5kZXggPSBtb2NrVXNlcnMuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgICBpZiAodXNlckluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuICAgIFxuICAgIG1vY2tVc2Vyc1t1c2VySW5kZXhdID0geyAuLi5tb2NrVXNlcnNbdXNlckluZGV4XSwgLi4udXBkYXRlcyB9O1xuICAgIHRoaXMubG9nQWN0aW9uKCdVU0VSX1VQREFURUQnLCAndXNlcicsIHsgdXNlcklkLCB1cGRhdGVzIH0pO1xuICAgIHJldHVybiBtb2NrVXNlcnNbdXNlckluZGV4XTtcbiAgfVxuXG4gIC8vIEJyYW5jaCBNYW5hZ2VtZW50XG4gIGFzeW5jIGNyZWF0ZUJyYW5jaChicmFuY2hEYXRhOiBQYXJ0aWFsPEJyYW5jaD4pOiBQcm9taXNlPEJyYW5jaD4ge1xuICAgIGNvbnN0IG5ld0JyYW5jaDogQnJhbmNoID0ge1xuICAgICAgaWQ6IGBicmFuY2hfJHtEYXRlLm5vdygpfWAsXG4gICAgICBicmFuY2hDb2RlOiBicmFuY2hEYXRhLmJyYW5jaENvZGUhLFxuICAgICAgbmFtZTogYnJhbmNoRGF0YS5uYW1lISxcbiAgICAgIHJlZ2lvbjogYnJhbmNoRGF0YS5yZWdpb24hLFxuICAgICAgdHlwZTogYnJhbmNoRGF0YS50eXBlISxcbiAgICAgIHN0YXRlOiBicmFuY2hEYXRhLnN0YXRlLFxuICAgICAgY291bnRyeTogYnJhbmNoRGF0YS5jb3VudHJ5LFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICBtb2NrQnJhbmNoZXMucHVzaChuZXdCcmFuY2gpO1xuICAgIHRoaXMubG9nQWN0aW9uKCdCUkFOQ0hfQ1JFQVRFRCcsICdicmFuY2gnLCBuZXdCcmFuY2gpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG4gIH1cblxuICBhc3luYyBnZXRCcmFuY2hlcygpOiBQcm9taXNlPEJyYW5jaFtdPiB7XG4gICAgcmV0dXJuIFsuLi5tb2NrQnJhbmNoZXNdO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlQnJhbmNoKGJyYW5jaElkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8QnJhbmNoPik6IFByb21pc2U8QnJhbmNoPiB7XG4gICAgY29uc3QgYnJhbmNoSW5kZXggPSBtb2NrQnJhbmNoZXMuZmluZEluZGV4KGIgPT4gYi5pZCA9PT0gYnJhbmNoSWQpO1xuICAgIGlmIChicmFuY2hJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQnJhbmNoIG5vdCBmb3VuZCcpO1xuICAgIFxuICAgIG1vY2tCcmFuY2hlc1ticmFuY2hJbmRleF0gPSB7IFxuICAgICAgLi4ubW9ja0JyYW5jaGVzW2JyYW5jaEluZGV4XSwgXG4gICAgICAuLi51cGRhdGVzLCBcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIFxuICAgIH07XG4gICAgdGhpcy5sb2dBY3Rpb24oJ0JSQU5DSF9VUERBVEVEJywgJ2JyYW5jaCcsIHsgYnJhbmNoSWQsIHVwZGF0ZXMgfSk7XG4gICAgcmV0dXJuIG1vY2tCcmFuY2hlc1ticmFuY2hJbmRleF07XG4gIH1cblxuICBhc3luYyBkZWxldGVCcmFuY2goYnJhbmNoSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGJyYW5jaEluZGV4ID0gbW9ja0JyYW5jaGVzLmZpbmRJbmRleChiID0+IGIuaWQgPT09IGJyYW5jaElkKTtcbiAgICBpZiAoYnJhbmNoSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0JyYW5jaCBub3QgZm91bmQnKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBicmFuY2ggaGFzIHVzZXJzXG4gICAgY29uc3QgYnJhbmNoVXNlcnMgPSBtb2NrVXNlcnMuZmlsdGVyKHUgPT4gdS5icmFuY2hJZCA9PT0gYnJhbmNoSWQpO1xuICAgIGlmIChicmFuY2hVc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgYnJhbmNoIHdpdGggZXhpc3RpbmcgdXNlcnMuIFBsZWFzZSByZWFzc2lnbiB1c2VycyBmaXJzdC4nKTtcbiAgICB9XG4gICAgXG4gICAgbW9ja0JyYW5jaGVzLnNwbGljZShicmFuY2hJbmRleCwgMSk7XG4gICAgdGhpcy5sb2dBY3Rpb24oJ0JSQU5DSF9ERUxFVEVEJywgJ2JyYW5jaCcsIHsgYnJhbmNoSWQgfSk7XG4gIH1cblxuICBhc3luYyBnZXREaXN0aW5jdFJlZ2lvbnMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHJlZ2lvbnMgPSBuZXcgU2V0KG1vY2tCcmFuY2hlcy5tYXAoYiA9PiBiLnJlZ2lvbikpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJlZ2lvbnMpO1xuICB9XG5cbiAgYXN5bmMgc2VhcmNoQnJhbmNoZXMoc2VhcmNoVGVybTogc3RyaW5nKTogUHJvbWlzZTxCcmFuY2hbXT4ge1xuICAgIGNvbnN0IHRlcm0gPSBzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1vY2tCcmFuY2hlcy5maWx0ZXIoYnJhbmNoID0+IFxuICAgICAgYnJhbmNoLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgYnJhbmNoLmJyYW5jaENvZGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgYnJhbmNoLnJlZ2lvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pXG4gICAgKTtcbiAgfVxuXG4gIC8vIEJyYW5jaCBJbnZlbnRvcnkgTWFuYWdlbWVudFxuICBhc3luYyBnZXRCcmFuY2hJbnZlbnRvcnkoYnJhbmNoSWQ/OiBzdHJpbmcpOiBQcm9taXNlPEJyYW5jaEludmVudG9yeVtdPiB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB0aGlzLmdldEN1cnJlbnRVc2VyKCk7XG4gICAgY29uc3QgYnJhbmNoZXMgPSBicmFuY2hJZCA/IG1vY2tCcmFuY2hlcy5maWx0ZXIoYiA9PiBiLmlkID09PSBicmFuY2hJZCkgOiBtb2NrQnJhbmNoZXM7XG4gICAgXG4gICAgcmV0dXJuIGJyYW5jaGVzLm1hcChicmFuY2ggPT4ge1xuICAgICAgY29uc3QgYnJhbmNoUVJzID0gbW9ja1FSQ29kZXMuZmlsdGVyKHFyID0+IHFyLmFsbG9jYXRlZEJyYW5jaElkID09PSBicmFuY2guaWQpO1xuICAgICAgXG4gICAgICBsZXQgdG90YWxBbGxvY2F0ZWQsIGlzc3VlZCwgYXZhaWxhYmxlLCByZXR1cm5lZCwgYmxvY2tlZDtcbiAgICAgIFxuICAgICAgLy8gRm9yIHNhbGVzIHVzZXJzLCBzaG93IG9ubHkgdGhlaXIgUVJzXG4gICAgICBpZiAoY3VycmVudFVzZXI/LnJvbGUgPT09ICdzYWxlc191c2VyJyAmJiBjdXJyZW50VXNlci5icmFuY2hJZCA9PT0gYnJhbmNoLmlkKSB7XG4gICAgICAgIGNvbnN0IHVzZXJRUnMgPSBicmFuY2hRUnMuZmlsdGVyKHFyID0+IHFyLmFsbG9jYXRlZFRvVXNlcklkID09PSBjdXJyZW50VXNlci5pZCk7XG4gICAgICAgIHRvdGFsQWxsb2NhdGVkID0gdXNlclFScy5sZW5ndGg7XG4gICAgICAgIGlzc3VlZCA9IHVzZXJRUnMuZmlsdGVyKHFyID0+IHFyLnN0YXR1cyA9PT0gJ2lzc3VlZCcpLmxlbmd0aDtcbiAgICAgICAgYXZhaWxhYmxlID0gdXNlclFScy5maWx0ZXIocXIgPT4gcXIuc3RhdHVzID09PSAnYWxsb2NhdGVkJykubGVuZ3RoO1xuICAgICAgICByZXR1cm5lZCA9IHVzZXJRUnMuZmlsdGVyKHFyID0+IHFyLnN0YXR1cyA9PT0gJ3JldHVybmVkJykubGVuZ3RoO1xuICAgICAgICBibG9ja2VkID0gdXNlclFScy5maWx0ZXIocXIgPT4gcXIuc3RhdHVzID09PSAnYmxvY2tlZCcpLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvdGhlciByb2xlcywgc2hvdyBicmFuY2gtd2lkZSBkYXRhXG4gICAgICAgIHRvdGFsQWxsb2NhdGVkID0gYnJhbmNoUVJzLmxlbmd0aDtcbiAgICAgICAgaXNzdWVkID0gYnJhbmNoUVJzLmZpbHRlcihxciA9PiBxci5zdGF0dXMgPT09ICdpc3N1ZWQnKS5sZW5ndGg7XG4gICAgICAgIGF2YWlsYWJsZSA9IGJyYW5jaFFScy5maWx0ZXIocXIgPT4gcXIuc3RhdHVzID09PSAnYWxsb2NhdGVkJykubGVuZ3RoO1xuICAgICAgICByZXR1cm5lZCA9IGJyYW5jaFFScy5maWx0ZXIocXIgPT4gcXIuc3RhdHVzID09PSAncmV0dXJuZWQnKS5sZW5ndGg7XG4gICAgICAgIGJsb2NrZWQgPSBicmFuY2hRUnMuZmlsdGVyKHFyID0+IHFyLnN0YXR1cyA9PT0gJ2Jsb2NrZWQnKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHV0aWxpemF0aW9uUmF0ZSA9IHRvdGFsQWxsb2NhdGVkID4gMCA/IE1hdGgucm91bmQoKGlzc3VlZCAvIHRvdGFsQWxsb2NhdGVkKSAqIDEwMCkgOiAwO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBicmFuY2hJZDogYnJhbmNoLmlkLFxuICAgICAgICBicmFuY2hOYW1lOiBicmFuY2gubmFtZSxcbiAgICAgICAgYnJhbmNoQ29kZTogYnJhbmNoLmJyYW5jaENvZGUsXG4gICAgICAgIHRvdGFsQWxsb2NhdGVkLFxuICAgICAgICBpc3N1ZWQsXG4gICAgICAgIGF2YWlsYWJsZSxcbiAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgIGJsb2NrZWQsXG4gICAgICAgIHV0aWxpemF0aW9uUmF0ZSxcbiAgICAgICAgbGFzdEFjdGl2aXR5OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBCdWxrIFFSIEFsbG9jYXRpb25cbiAgYXN5bmMgYnVsa0FsbG9jYXRlUVJzKGJyYW5jaElkOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB1bmFsbG9jYXRlZFFScyA9IG1vY2tRUkNvZGVzLmZpbHRlcihxciA9PiBxci5zdGF0dXMgPT09ICd1bmFsbG9jYXRlZCcpLnNsaWNlKDAsIGNvdW50KTtcbiAgICBcbiAgICBpZiAodW5hbGxvY2F0ZWRRUnMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSAke3VuYWxsb2NhdGVkUVJzLmxlbmd0aH0gdW5hbGxvY2F0ZWQgUVIgY29kZXMgYXZhaWxhYmxlYCk7XG4gICAgfVxuICAgIFxuICAgIHVuYWxsb2NhdGVkUVJzLmZvckVhY2gocXIgPT4ge1xuICAgICAgcXIuc3RhdHVzID0gJ2FsbG9jYXRlZCc7XG4gICAgICBxci5hbGxvY2F0ZWRCcmFuY2hJZCA9IGJyYW5jaElkO1xuICAgICAgcXIudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdCVUxLX1FSX0FMTE9DQVRFRCcsICdxcl9jb2RlJywgeyBicmFuY2hJZCwgY291bnQsIHFySWRzOiB1bmFsbG9jYXRlZFFScy5tYXAocXIgPT4gcXIuaWQpIH0pO1xuICB9XG5cbiAgLy8gQnVsayBRUiBBc3NpZ25tZW50IGJldHdlZW4gYnJhbmNoZXNcbiAgYXN5bmMgYnVsa0Fzc2lnblFScyhzb3VyY2VCcmFuY2hJZDogc3RyaW5nLCB0YXJnZXRCcmFuY2hJZDogc3RyaW5nLCBjb3VudDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc291cmNlUVJzID0gbW9ja1FSQ29kZXMuZmlsdGVyKHFyID0+IFxuICAgICAgcXIuYWxsb2NhdGVkQnJhbmNoSWQgPT09IHNvdXJjZUJyYW5jaElkICYmIHFyLnN0YXR1cyA9PT0gJ2FsbG9jYXRlZCdcbiAgICApLnNsaWNlKDAsIGNvdW50KTtcbiAgICBcbiAgICBpZiAoc291cmNlUVJzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgJHtzb3VyY2VRUnMubGVuZ3RofSBhdmFpbGFibGUgUVIgY29kZXMgaW4gc291cmNlIGJyYW5jaGApO1xuICAgIH1cbiAgICBcbiAgICBzb3VyY2VRUnMuZm9yRWFjaChxciA9PiB7XG4gICAgICBxci5hbGxvY2F0ZWRCcmFuY2hJZCA9IHRhcmdldEJyYW5jaElkO1xuICAgICAgcXIudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdCVUxLX1FSX0FTU0lHTkVEJywgJ3FyX2NvZGUnLCB7IFxuICAgICAgc291cmNlQnJhbmNoSWQsIFxuICAgICAgdGFyZ2V0QnJhbmNoSWQsIFxuICAgICAgY291bnQsIFxuICAgICAgcXJJZHM6IHNvdXJjZVFScy5tYXAocXIgPT4gcXIuaWQpIFxuICAgIH0pO1xuICB9XG5cbiAgLy8gVGhyZXNob2xkIFJlcXVlc3RzXG4gIGFzeW5jIGNyZWF0ZVRocmVzaG9sZFJlcXVlc3QoYnJhbmNoSWQ6IHN0cmluZywgZGF0YTogeyBjdXJyZW50SW52ZW50b3J5OiBudW1iZXI7IHRocmVzaG9sZDogbnVtYmVyOyByZXF1ZXN0ZWRBbW91bnQ6IG51bWJlcjsgcmVhc29uOiBzdHJpbmcgfSk6IFByb21pc2U8VGhyZXNob2xkUmVxdWVzdD4ge1xuICAgIGNvbnN0IHJlcXVlc3Q6IFRocmVzaG9sZFJlcXVlc3QgPSB7XG4gICAgICBpZDogYHRocmVzaF8ke0RhdGUubm93KCl9YCxcbiAgICAgIGJyYW5jaElkLFxuICAgICAgY3VycmVudEludmVudG9yeTogZGF0YS5jdXJyZW50SW52ZW50b3J5LFxuICAgICAgdGhyZXNob2xkOiBkYXRhLnRocmVzaG9sZCxcbiAgICAgIHJlcXVlc3RlZEFtb3VudDogZGF0YS5yZXF1ZXN0ZWRBbW91bnQsXG4gICAgICByZWFzb246IGRhdGEucmVhc29uLFxuICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICBjcmVhdGVkQnk6IHRoaXMuY3VycmVudFVzZXI/LmlkIHx8ICcxJyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnRocmVzaG9sZFJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgdGhpcy5sb2dBY3Rpb24oJ1RIUkVTSE9MRF9SRVFVRVNUX0NSRUFURUQnLCAndGhyZXNob2xkX3JlcXVlc3QnLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIGFzeW5jIGdldFRocmVzaG9sZFJlcXVlc3RzKGJyYW5jaElkPzogc3RyaW5nKTogUHJvbWlzZTxUaHJlc2hvbGRSZXF1ZXN0W10+IHtcbiAgICBsZXQgcmVxdWVzdHMgPSBbLi4udGhpcy50aHJlc2hvbGRSZXF1ZXN0c107XG4gICAgaWYgKGJyYW5jaElkKSB7XG4gICAgICByZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcihyID0+IHIuYnJhbmNoSWQgPT09IGJyYW5jaElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3RzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuY3JlYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCkuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGFzeW5jIGFwcHJvdmVUaHJlc2hvbGRSZXF1ZXN0KHJlcXVlc3RJZDogc3RyaW5nLCBub3Rlcz86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnRocmVzaG9sZFJlcXVlc3RzLmZpbmQociA9PiByLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LnN0YXR1cyA9ICdhcHByb3ZlZCc7XG4gICAgICByZXF1ZXN0LnJldmlld2VkQnkgPSB0aGlzLmN1cnJlbnRVc2VyPy5pZDtcbiAgICAgIHJlcXVlc3QucmV2aWV3ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIFxuICAgICAgLy8gQXV0by1hbGxvY2F0ZSB0aGUgcmVxdWVzdGVkIFFSc1xuICAgICAgYXdhaXQgdGhpcy5idWxrQWxsb2NhdGVRUnMocmVxdWVzdC5icmFuY2hJZCwgcmVxdWVzdC5yZXF1ZXN0ZWRBbW91bnQpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignVEhSRVNIT0xEX1JFUVVFU1RfQVBQUk9WRUQnLCAndGhyZXNob2xkX3JlcXVlc3QnLCB7IHJlcXVlc3RJZCwgbm90ZXMgfSk7XG4gIH1cblxuICBhc3luYyByZWplY3RUaHJlc2hvbGRSZXF1ZXN0KHJlcXVlc3RJZDogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnRocmVzaG9sZFJlcXVlc3RzLmZpbmQociA9PiByLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICByZXF1ZXN0LnJldmlld2VkQnkgPSB0aGlzLmN1cnJlbnRVc2VyPy5pZDtcbiAgICAgIHJlcXVlc3QucmV2aWV3ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sb2dBY3Rpb24oJ1RIUkVTSE9MRF9SRVFVRVNUX1JFSkVDVEVEJywgJ3RocmVzaG9sZF9yZXF1ZXN0JywgeyByZXF1ZXN0SWQsIHJlYXNvbiB9KTtcbiAgfVxuXG4gIC8vIE1lcmNoYW50IE1hbmFnZW1lbnRcbiAgYXN5bmMgY3JlYXRlTWVyY2hhbnQobWVyY2hhbnREYXRhOiBQYXJ0aWFsPE1lcmNoYW50Pik6IFByb21pc2U8TWVyY2hhbnQ+IHtcbiAgICBjb25zdCBuZXdNZXJjaGFudDogTWVyY2hhbnQgPSB7XG4gICAgICBpZDogYG1lcmNoYW50XyR7RGF0ZS5ub3coKX1gLFxuICAgICAgbGVnYWxOYW1lOiBtZXJjaGFudERhdGEubGVnYWxOYW1lISxcbiAgICAgIHNob3BOYW1lOiBtZXJjaGFudERhdGEuc2hvcE5hbWUhLFxuICAgICAgYWRkcmVzczogbWVyY2hhbnREYXRhLmFkZHJlc3MhLFxuICAgICAgcGhvbmU6IG1lcmNoYW50RGF0YS5waG9uZSEsXG4gICAgICBlbWFpbDogbWVyY2hhbnREYXRhLmVtYWlsISxcbiAgICAgIGt5Y1N0YXR1czogJ3BlbmRpbmcnLCAvLyBBbHdheXMgc3RhcnRzIGFzIHBlbmRpbmdcbiAgICAgIGJyYW5jaElkOiB0aGlzLmN1cnJlbnRVc2VyPy5icmFuY2hJZCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLm1lcmNoYW50cy5wdXNoKG5ld01lcmNoYW50KTtcbiAgICB0aGlzLmxvZ0FjdGlvbignTUVSQ0hBTlRfQ1JFQVRFRCcsICdtZXJjaGFudCcsIG5ld01lcmNoYW50KTtcbiAgICByZXR1cm4gbmV3TWVyY2hhbnQ7XG4gIH1cblxuICBhc3luYyBnZXRNZXJjaGFudHMoYnJhbmNoSWQ/OiBzdHJpbmcpOiBQcm9taXNlPE1lcmNoYW50W10+IHtcbiAgICAvLyBGaWx0ZXIgbWVyY2hhbnRzIGJ5IGJyYW5jaCBpZiBicmFuY2hJZCBpcyBwcm92aWRlZFxuICAgIGlmIChicmFuY2hJZCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVyY2hhbnRzLmZpbHRlcihtID0+IG0uYnJhbmNoSWQgPT09IGJyYW5jaElkKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLm1lcmNoYW50c107XG4gIH1cblxuICBhc3luYyBkZWxldGVNZXJjaGFudChtZXJjaGFudElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXJjaGFudEluZGV4ID0gdGhpcy5tZXJjaGFudHMuZmluZEluZGV4KG0gPT4gbS5pZCA9PT0gbWVyY2hhbnRJZCk7XG4gICAgaWYgKG1lcmNoYW50SW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ01lcmNoYW50IG5vdCBmb3VuZCcpO1xuICAgIFxuICAgIHRoaXMubWVyY2hhbnRzLnNwbGljZShtZXJjaGFudEluZGV4LCAxKTtcbiAgICB0aGlzLmxvZ0FjdGlvbignTUVSQ0hBTlRfREVMRVRFRCcsICdtZXJjaGFudCcsIHsgbWVyY2hhbnRJZCB9KTtcbiAgfVxuXG4gIC8vIE1lcmNoYW50IFFSIFJlcXVlc3RzXG4gIGFzeW5jIGNyZWF0ZU1lcmNoYW50UVJSZXF1ZXN0KGRhdGE6IHtcbiAgICBtZXJjaGFudElkOiBzdHJpbmc7XG4gICAgcmVxdWVzdGVkUXJDb3VudDogbnVtYmVyO1xuICAgIGJ1c2luZXNzSnVzdGlmaWNhdGlvbjogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxNZXJjaGFudFJlcXVlc3Q+IHtcbiAgICBjb25zdCByZXF1ZXN0OiBNZXJjaGFudFJlcXVlc3QgPSB7XG4gICAgICBpZDogYG1lcl9yZXFfJHtEYXRlLm5vdygpfWAsXG4gICAgICBtZXJjaGFudElkOiBkYXRhLm1lcmNoYW50SWQsXG4gICAgICByZXF1ZXN0ZWRCeTogdGhpcy5jdXJyZW50VXNlcj8uaWQgfHwgJzEnLFxuICAgICAgYnJhbmNoSWQ6IHRoaXMuY3VycmVudFVzZXI/LmJyYW5jaElkIHx8ICcxJyxcbiAgICAgIHJlcXVlc3RlZFFyQ291bnQ6IGRhdGEucmVxdWVzdGVkUXJDb3VudCxcbiAgICAgIGJ1c2luZXNzSnVzdGlmaWNhdGlvbjogZGF0YS5idXNpbmVzc0p1c3RpZmljYXRpb24sXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLm1lcmNoYW50UmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICB0aGlzLmxvZ0FjdGlvbignTUVSQ0hBTlRfUVJfUkVRVUVTVF9DUkVBVEVEJywgJ21lcmNoYW50X3JlcXVlc3QnLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIGFzeW5jIGdldE1lcmNoYW50UVJSZXF1ZXN0cyhicmFuY2hJZD86IHN0cmluZyk6IFByb21pc2U8TWVyY2hhbnRSZXF1ZXN0W10+IHtcbiAgICBsZXQgcmVxdWVzdHMgPSBbLi4udGhpcy5tZXJjaGFudFJlcXVlc3RzXTtcbiAgICBpZiAoYnJhbmNoSWQpIHtcbiAgICAgIHJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHIgPT4gci5icmFuY2hJZCA9PT0gYnJhbmNoSWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdHMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgYXN5bmMgYXBwcm92ZU1lcmNoYW50UVJSZXF1ZXN0KHJlcXVlc3RJZDogc3RyaW5nLCBub3Rlcz86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm1lcmNoYW50UmVxdWVzdHMuZmluZChyID0+IHIuaWQgPT09IHJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2FwcHJvdmVkJztcbiAgICAgIHJlcXVlc3QuYXBwcm92ZWRCeSA9IHRoaXMuY3VycmVudFVzZXI/LmlkO1xuICAgICAgcmVxdWVzdC5hcHByb3ZlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgXG4gICAgICAvLyBBdXRvLWFsbG9jYXRlIFFScyB0byB0aGUgcmVxdWVzdGluZyBicmFuY2hcbiAgICAgIGF3YWl0IHRoaXMuYnVsa0FsbG9jYXRlUVJzKHJlcXVlc3QuYnJhbmNoSWQsIHJlcXVlc3QucmVxdWVzdGVkUXJDb3VudCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdNRVJDSEFOVF9RUl9SRVFVRVNUX0FQUFJPVkVEJywgJ21lcmNoYW50X3JlcXVlc3QnLCB7IHJlcXVlc3RJZCwgbm90ZXMgfSk7XG4gIH1cblxuICBhc3luYyByZWplY3RNZXJjaGFudFFSUmVxdWVzdChyZXF1ZXN0SWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5tZXJjaGFudFJlcXVlc3RzLmZpbmQociA9PiByLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICByZXF1ZXN0LmFwcHJvdmVkQnkgPSB0aGlzLmN1cnJlbnRVc2VyPy5pZDtcbiAgICAgIHJlcXVlc3QucmVqZWN0aW9uUmVhc29uID0gcmVhc29uO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignTUVSQ0hBTlRfUVJfUkVRVUVTVF9SRUpFQ1RFRCcsICdtZXJjaGFudF9yZXF1ZXN0JywgeyByZXF1ZXN0SWQsIHJlYXNvbiB9KTtcbiAgfVxuXG4gIC8vIEtZQyBNYW5hZ2VtZW50XG4gIGFzeW5jIGNyZWF0ZUtZQ1JlcXVlc3QoZGF0YToge1xuICAgIG1lcmNoYW50SWQ6IHN0cmluZztcbiAgICBkb2N1bWVudHM6IEtZQ1JlcXVlc3RbJ2RvY3VtZW50cyddO1xuICB9KTogUHJvbWlzZTxLWUNSZXF1ZXN0PiB7XG4gICAgLy8gQ2hlY2sgaWYgS1lDIHJlcXVlc3QgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgbWVyY2hhbnRcbiAgICBjb25zdCBleGlzdGluZ1JlcXVlc3QgPSB0aGlzLmt5Y1JlcXVlc3RzLmZpbmQociA9PiByLm1lcmNoYW50SWQgPT09IGRhdGEubWVyY2hhbnRJZCAmJiByLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgS1lDIHJlcXVlc3QgaXMgYWxyZWFkeSBwZW5kaW5nIGZvciB0aGlzIG1lcmNoYW50Jyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlcXVlc3Q6IEtZQ1JlcXVlc3QgPSB7XG4gICAgICBpZDogYGt5Y18ke0RhdGUubm93KCl9YCxcbiAgICAgIG1lcmNoYW50SWQ6IGRhdGEubWVyY2hhbnRJZCxcbiAgICAgIHJlcXVlc3RlZEJ5OiB0aGlzLmN1cnJlbnRVc2VyPy5pZCB8fCAnMScsXG4gICAgICBicmFuY2hJZDogdGhpcy5jdXJyZW50VXNlcj8uYnJhbmNoSWQgfHwgJzEnLFxuICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICBkb2N1bWVudHM6IGRhdGEuZG9jdW1lbnRzLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5reWNSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHRoaXMubG9nQWN0aW9uKCdLWUNfUkVRVUVTVF9DUkVBVEVEJywgJ2t5Y19yZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICBhc3luYyBnZXRLWUNSZXF1ZXN0cyhicmFuY2hJZD86IHN0cmluZyk6IFByb21pc2U8S1lDUmVxdWVzdFtdPiB7XG4gICAgbGV0IHJlcXVlc3RzID0gWy4uLnRoaXMua3ljUmVxdWVzdHNdO1xuICAgIGlmIChicmFuY2hJZCkge1xuICAgICAgcmVxdWVzdHMgPSByZXF1ZXN0cy5maWx0ZXIociA9PiByLmJyYW5jaElkID09PSBicmFuY2hJZCk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0cy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSk7XG4gIH1cblxuICBhc3luYyBhcHByb3ZlS1lDUmVxdWVzdChyZXF1ZXN0SWQ6IHN0cmluZywgbm90ZXM/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5reWNSZXF1ZXN0cy5maW5kKHIgPT4gci5pZCA9PT0gcmVxdWVzdElkKTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnYXBwcm92ZWQnO1xuICAgICAgcmVxdWVzdC5yZXZpZXdlZEJ5ID0gdGhpcy5jdXJyZW50VXNlcj8uaWQ7XG4gICAgICByZXF1ZXN0LnJldmlld2VkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICByZXF1ZXN0LnJldmlld05vdGVzID0gbm90ZXM7XG4gICAgICByZXF1ZXN0LnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIG1lcmNoYW50IEtZQyBzdGF0dXNcbiAgICAgIGNvbnN0IG1lcmNoYW50ID0gdGhpcy5tZXJjaGFudHMuZmluZChtID0+IG0uaWQgPT09IHJlcXVlc3QubWVyY2hhbnRJZCk7XG4gICAgICBpZiAobWVyY2hhbnQpIHtcbiAgICAgICAgbWVyY2hhbnQua3ljU3RhdHVzID0gJ3ZlcmlmaWVkJztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5sb2dBY3Rpb24oJ0tZQ19SRVFVRVNUX0FQUFJPVkVEJywgJ2t5Y19yZXF1ZXN0JywgeyByZXF1ZXN0SWQsIG5vdGVzIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVqZWN0S1lDUmVxdWVzdChyZXF1ZXN0SWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5reWNSZXF1ZXN0cy5maW5kKHIgPT4gci5pZCA9PT0gcmVxdWVzdElkKTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgcmVxdWVzdC5yZXZpZXdlZEJ5ID0gdGhpcy5jdXJyZW50VXNlcj8uaWQ7XG4gICAgICByZXF1ZXN0LnJldmlld2VkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICByZXF1ZXN0LnJldmlld05vdGVzID0gcmVhc29uO1xuICAgICAgcmVxdWVzdC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBtZXJjaGFudCBLWUMgc3RhdHVzXG4gICAgICBjb25zdCBtZXJjaGFudCA9IHRoaXMubWVyY2hhbnRzLmZpbmQobSA9PiBtLmlkID09PSByZXF1ZXN0Lm1lcmNoYW50SWQpO1xuICAgICAgaWYgKG1lcmNoYW50KSB7XG4gICAgICAgIG1lcmNoYW50Lmt5Y1N0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdLWUNfUkVRVUVTVF9SRUpFQ1RFRCcsICdreWNfcmVxdWVzdCcsIHsgcmVxdWVzdElkLCByZWFzb24gfSk7XG4gIH1cblxuICAvLyBBdWRpdCBNYW5hZ2VtZW50IChmb3IgQXVkaXRvciByb2xlKVxuICBhc3luYyBnZXRBdWRpdExvZ3MoZmlsdGVycz86IHsgXG4gICAgZGF0ZUZyb20/OiBzdHJpbmc7IFxuICAgIGRhdGVUbz86IHN0cmluZzsgXG4gICAgYWN0aW9uVHlwZT86IHN0cmluZzsgXG4gICAgdXNlcklkPzogc3RyaW5nOyBcbiAgICBicmFuY2hJZD86IHN0cmluZyBcbiAgfSk6IFByb21pc2U8QXVkaXRMb2dbXT4ge1xuICAgIGxldCBsb2dzID0gWy4uLm1vY2tBdWRpdExvZ3NdO1xuICAgIFxuICAgIGlmIChmaWx0ZXJzPy5kYXRlRnJvbSkge1xuICAgICAgbG9ncyA9IGxvZ3MuZmlsdGVyKGxvZyA9PiBuZXcgRGF0ZShsb2cudGltZXN0YW1wKSA+PSBuZXcgRGF0ZShmaWx0ZXJzLmRhdGVGcm9tISkpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycz8uZGF0ZVRvKSB7XG4gICAgICBsb2dzID0gbG9ncy5maWx0ZXIobG9nID0+IG5ldyBEYXRlKGxvZy50aW1lc3RhbXApIDw9IG5ldyBEYXRlKGZpbHRlcnMuZGF0ZVRvISkpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycz8uYWN0aW9uVHlwZSkge1xuICAgICAgbG9ncyA9IGxvZ3MuZmlsdGVyKGxvZyA9PiBsb2cuYWN0aW9uVHlwZSA9PT0gZmlsdGVycy5hY3Rpb25UeXBlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnM/LnVzZXJJZCkge1xuICAgICAgbG9ncyA9IGxvZ3MuZmlsdGVyKGxvZyA9PiBsb2cuYWN0b3JVc2VySWQgPT09IGZpbHRlcnMudXNlcklkKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnM/LmJyYW5jaElkKSB7XG4gICAgICBsb2dzID0gbG9ncy5maWx0ZXIobG9nID0+IGxvZy5wYXlsb2FkPy5icmFuY2hJZCA9PT0gZmlsdGVycy5icmFuY2hJZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsb2dzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudGltZXN0YW1wKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlQXVkaXRSZXBvcnQodHlwZTogJ2NvbXBsaWFuY2UnIHwgJ3NlY3VyaXR5JyB8ICdwZXJmb3JtYW5jZScgfCAndXNlcl9hY3Rpdml0eScsIGZpbHRlcnM/OiB7XG4gICAgZGF0ZUZyb20/OiBzdHJpbmc7XG4gICAgZGF0ZVRvPzogc3RyaW5nO1xuICAgIGJyYW5jaElkPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy5nZXRBdWRpdExvZ3MoZmlsdGVycyk7XG4gICAgXG4gICAgY29uc3QgcmVwb3J0ID0ge1xuICAgICAgaWQ6IGBhdWRpdF9yZXBvcnRfJHtEYXRlLm5vdygpfWAsXG4gICAgICB0eXBlLFxuICAgICAgZ2VuZXJhdGVkQnk6IHRoaXMuY3VycmVudFVzZXI/LmlkLFxuICAgICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGZpbHRlcnMsXG4gICAgICBzdW1tYXJ5OiB0aGlzLmdlbmVyYXRlQXVkaXRTdW1tYXJ5KGxvZ3MsIHR5cGUpLFxuICAgICAgZGV0YWlsczogdGhpcy5nZW5lcmF0ZUF1ZGl0RGV0YWlscyhsb2dzLCB0eXBlKSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogdGhpcy5nZW5lcmF0ZUF1ZGl0UmVjb21tZW5kYXRpb25zKGxvZ3MsIHR5cGUpXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmxvZ0FjdGlvbignQVVESVRfUkVQT1JUX0dFTkVSQVRFRCcsICdhdWRpdF9yZXBvcnQnLCB7IHJlcG9ydFR5cGU6IHR5cGUsIGZpbHRlcnMgfSk7XG4gICAgcmV0dXJuIHJlcG9ydDtcbiAgfVxuXG4gIC8vIEF1ZGl0IEl0ZW0gTWFuYWdlbWVudCAoZm9yIEF1ZGl0b3Igcm9sZSlcbiAgYXN5bmMgZ2V0QXVkaXRJdGVtcyhmaWx0ZXJzPzoge1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgICByaXNrTGV2ZWw/OiBzdHJpbmc7XG4gICAgYnJhbmNoSWQ/OiBzdHJpbmc7XG4gICAgZHVlRGF0ZT86IHN0cmluZztcbiAgfSk6IFByb21pc2U8QXVkaXRJdGVtW10+IHtcbiAgICBsZXQgaXRlbXMgPSBbLi4udGhpcy5hdWRpdEl0ZW1zXTtcbiAgICBcbiAgICBpZiAoZmlsdGVycz8uY2F0ZWdvcnkpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSA9PT0gZmlsdGVycy5jYXRlZ29yeSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzPy5zdGF0dXMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09IGZpbHRlcnMuc3RhdHVzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnM/LnJpc2tMZXZlbCkge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnJpc2tMZXZlbCA9PT0gZmlsdGVycy5yaXNrTGV2ZWwpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycz8uYnJhbmNoSWQpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5icmFuY2hJZCA9PT0gZmlsdGVycy5icmFuY2hJZCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzPy5kdWVEYXRlKSB7XG4gICAgICBjb25zdCBmaWx0ZXJEYXRlID0gbmV3IERhdGUoZmlsdGVycy5kdWVEYXRlKTtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gbmV3IERhdGUoaXRlbS5kdWVEYXRlKSA8PSBmaWx0ZXJEYXRlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGl0ZW1zLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudXBkYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnVwZGF0ZWRBdCkuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUF1ZGl0SXRlbShpdGVtSWQ6IHN0cmluZywgdXBkYXRlczoge1xuICAgIHN0YXR1cz86IEF1ZGl0SXRlbVsnc3RhdHVzJ107XG4gICAgZmluZGluZ3M/OiBzdHJpbmc7XG4gICAgcmVjb21tZW5kYXRpb25zPzogc3RyaW5nO1xuICAgIHNjb3JlPzogbnVtYmVyO1xuICAgIGV2aWRlbmNlPzogc3RyaW5nW107XG4gIH0pOiBQcm9taXNlPEF1ZGl0SXRlbT4ge1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IHRoaXMuYXVkaXRJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlkID09PSBpdGVtSWQpO1xuICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0F1ZGl0IGl0ZW0gbm90IGZvdW5kJyk7XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZEl0ZW0gPSB7XG4gICAgICAuLi50aGlzLmF1ZGl0SXRlbXNbaXRlbUluZGV4XSxcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICBhdWRpdGVkQnk6IHRoaXMuY3VycmVudFVzZXI/LmlkLFxuICAgICAgYXVkaXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXN0UmV2aWV3RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuYXVkaXRJdGVtc1tpdGVtSW5kZXhdID0gdXBkYXRlZEl0ZW07XG4gICAgdGhpcy5sb2dBY3Rpb24oJ0FVRElUX0lURU1fVVBEQVRFRCcsICdhdWRpdF9pdGVtJywgeyBpdGVtSWQsIHVwZGF0ZXMgfSk7XG4gICAgcmV0dXJuIHVwZGF0ZWRJdGVtO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQXVkaXRJdGVtKGl0ZW1EYXRhOiBQYXJ0aWFsPEF1ZGl0SXRlbT4pOiBQcm9taXNlPEF1ZGl0SXRlbT4ge1xuICAgIGNvbnN0IG5ld0l0ZW06IEF1ZGl0SXRlbSA9IHtcbiAgICAgIGlkOiBgYXVkaXRfaXRlbV8ke0RhdGUubm93KCl9YCxcbiAgICAgIGNhdGVnb3J5OiBpdGVtRGF0YS5jYXRlZ29yeSEsXG4gICAgICBzdWJjYXRlZ29yeTogaXRlbURhdGEuc3ViY2F0ZWdvcnkhLFxuICAgICAgdGl0bGU6IGl0ZW1EYXRhLnRpdGxlISxcbiAgICAgIGRlc2NyaXB0aW9uOiBpdGVtRGF0YS5kZXNjcmlwdGlvbiEsXG4gICAgICByaXNrTGV2ZWw6IGl0ZW1EYXRhLnJpc2tMZXZlbCEsXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIGR1ZURhdGU6IGl0ZW1EYXRhLmR1ZURhdGUhLFxuICAgICAgZXZpZGVuY2U6IFtdLFxuICAgICAgdGFyZ2V0RW50aXR5OiBpdGVtRGF0YS50YXJnZXRFbnRpdHkhLFxuICAgICAgdGFyZ2V0RW50aXR5SWQ6IGl0ZW1EYXRhLnRhcmdldEVudGl0eUlkISxcbiAgICAgIGJyYW5jaElkOiBpdGVtRGF0YS5icmFuY2hJZCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuYXVkaXRJdGVtcy5wdXNoKG5ld0l0ZW0pO1xuICAgIHRoaXMubG9nQWN0aW9uKCdBVURJVF9JVEVNX0NSRUFURUQnLCAnYXVkaXRfaXRlbScsIG5ld0l0ZW0pO1xuICAgIHJldHVybiBuZXdJdGVtO1xuICB9XG5cbiAgYXN5bmMgZ2V0QXVkaXRDaGVja2xpc3RzKCk6IFByb21pc2U8QXVkaXRDaGVja2xpc3RbXT4ge1xuICAgIC8vIFVwZGF0ZSBjaGVja2xpc3Qgc2NvcmVzIGJhc2VkIG9uIGN1cnJlbnQgYXVkaXQgaXRlbXNcbiAgICByZXR1cm4gdGhpcy5hdWRpdENoZWNrbGlzdHMubWFwKGNoZWNrbGlzdCA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuYXVkaXRJdGVtcy5maWx0ZXIoaXRlbSA9PiBcbiAgICAgICAgY2hlY2tsaXN0Lml0ZW1zLnNvbWUoY2hlY2tsaXN0SXRlbSA9PiBjaGVja2xpc3RJdGVtLmlkID09PSBpdGVtLmlkKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgY29tcGxldGVkSXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBcbiAgICAgICAgaXRlbS5zdGF0dXMgPT09ICdjb21wbGlhbnQnIHx8IGl0ZW0uc3RhdHVzID09PSAnbm9uX2NvbXBsaWFudCcgfHwgaXRlbS5zdGF0dXMgPT09ICdyZXF1aXJlc19hY3Rpb24nXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFNjb3JlID0gaXRlbXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnNjb3JlIHx8IDApLCAwKTtcbiAgICAgIGNvbnN0IGF2Z1Njb3JlID0gaXRlbXMubGVuZ3RoID4gMCA/IHRvdGFsU2NvcmUgLyBpdGVtcy5sZW5ndGggOiAwO1xuICAgICAgY29uc3QgY29tcGxldGlvblJhdGUgPSBpdGVtcy5sZW5ndGggPiAwID8gKGNvbXBsZXRlZEl0ZW1zLmxlbmd0aCAvIGl0ZW1zLmxlbmd0aCkgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jaGVja2xpc3QsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBvdmVyYWxsU2NvcmU6IE1hdGgucm91bmQoYXZnU2NvcmUpLFxuICAgICAgICBjb21wbGV0aW9uUmF0ZTogTWF0aC5yb3VuZChjb21wbGV0aW9uUmF0ZSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZUF1ZGl0U2NvcmVjYXJkKHBlcmlvZDogc3RyaW5nID0gJ2N1cnJlbnQnKTogUHJvbWlzZTxBdWRpdFNjb3JlY2FyZD4ge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5hdWRpdEl0ZW1zO1xuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbJ3FyX21hbmFnZW1lbnQnLCAndXNlcl9hY2Nlc3MnLCAnZGF0YV9wcm90ZWN0aW9uJywgJ3Byb2Nlc3NfY29tcGxpYW5jZScsICdzZWN1cml0eV9jb250cm9scycsICdreWNfdmVyaWZpY2F0aW9uJ107XG4gICAgXG4gICAgY29uc3QgY2F0ZWdvcnlTY29yZXMgPSBjYXRlZ29yaWVzLm1hcChjYXRlZ29yeSA9PiB7XG4gICAgICBjb25zdCBjYXRlZ29yeUl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgY29uc3QgY29tcGxpYW50Q291bnQgPSBjYXRlZ29yeUl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSAnY29tcGxpYW50JykubGVuZ3RoO1xuICAgICAgY29uc3Qgbm9uQ29tcGxpYW50Q291bnQgPSBjYXRlZ29yeUl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSAnbm9uX2NvbXBsaWFudCcpLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBlbmRpbmdDb3VudCA9IGNhdGVnb3J5SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09ICdwZW5kaW5nJyB8fCBpdGVtLnN0YXR1cyA9PT0gJ2luX3JldmlldycpLmxlbmd0aDtcbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxTY29yZSA9IGNhdGVnb3J5SXRlbXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnNjb3JlIHx8IDApLCAwKTtcbiAgICAgIGNvbnN0IGF2Z1Njb3JlID0gY2F0ZWdvcnlJdGVtcy5sZW5ndGggPiAwID8gdG90YWxTY29yZSAvIGNhdGVnb3J5SXRlbXMubGVuZ3RoIDogMTAwO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnkucmVwbGFjZSgnXycsICcgJykucmVwbGFjZSgvXFxiXFx3L2csIGwgPT4gbC50b1VwcGVyQ2FzZSgpKSxcbiAgICAgICAgc2NvcmU6IE1hdGgucm91bmQoYXZnU2NvcmUpLFxuICAgICAgICBpdGVtQ291bnQ6IGNhdGVnb3J5SXRlbXMubGVuZ3RoLFxuICAgICAgICBjb21wbGlhbnRDb3VudCxcbiAgICAgICAgbm9uQ29tcGxpYW50Q291bnQsXG4gICAgICAgIHBlbmRpbmdDb3VudFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBvdmVyYWxsU2NvcmUgPSBNYXRoLnJvdW5kKFxuICAgICAgY2F0ZWdvcnlTY29yZXMucmVkdWNlKChzdW0sIGNhdCkgPT4gc3VtICsgY2F0LnNjb3JlLCAwKSAvIGNhdGVnb3J5U2NvcmVzLmxlbmd0aFxuICAgICk7XG4gICAgXG4gICAgY29uc3QgaGlnaFJpc2tJc3N1ZXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBcbiAgICAgIGl0ZW0ucmlza0xldmVsID09PSAnaGlnaCcgfHwgaXRlbS5yaXNrTGV2ZWwgPT09ICdjcml0aWNhbCdcbiAgICApLmZpbHRlcihpdGVtID0+IFxuICAgICAgaXRlbS5zdGF0dXMgPT09ICdub25fY29tcGxpYW50JyB8fCBpdGVtLnN0YXR1cyA9PT0gJ3JlcXVpcmVzX2FjdGlvbidcbiAgICApLmxlbmd0aDtcbiAgICBcbiAgICBjb25zdCByaXNrTGV2ZWwgPSBoaWdoUmlza0lzc3VlcyA+IDIgPyAnaGlnaCcgOiBoaWdoUmlza0lzc3VlcyA+IDAgPyAnbWVkaXVtJyA6ICdsb3cnO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogYHNjb3JlY2FyZF8ke0RhdGUubm93KCl9YCxcbiAgICAgIHBlcmlvZCxcbiAgICAgIG92ZXJhbGxTY29yZSxcbiAgICAgIGNhdGVnb3J5U2NvcmVzLFxuICAgICAgcmlza0Fzc2Vzc21lbnQ6IHtcbiAgICAgICAgbGV2ZWw6IHJpc2tMZXZlbCxcbiAgICAgICAgc2NvcmU6IG92ZXJhbGxTY29yZSxcbiAgICAgICAgaXNzdWVzOiBoaWdoUmlza0lzc3VlcyxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiB0aGlzLmdlbmVyYXRlU2NvcmNhcmRSZWNvbW1lbmRhdGlvbnMoaXRlbXMpXG4gICAgICB9LFxuICAgICAgdHJlbmRzOiB7XG4gICAgICAgIHByZXZpb3VzU2NvcmU6IG92ZXJhbGxTY29yZSAtIDIuMywgLy8gTW9jayBwcmV2aW91cyBzY29yZVxuICAgICAgICBjaGFuZ2U6IDIuMyxcbiAgICAgICAgdHJlbmQ6ICdpbXByb3ZpbmcnXG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGdlbmVyYXRlZEJ5OiB0aGlzLmN1cnJlbnRVc2VyPy5pZCB8fCAnOSdcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVNjb3JjYXJkUmVjb21tZW5kYXRpb25zKGl0ZW1zOiBBdWRpdEl0ZW1bXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBbXTtcbiAgICBcbiAgICBjb25zdCBub25Db21wbGlhbnRJdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSAnbm9uX2NvbXBsaWFudCcpO1xuICAgIGNvbnN0IHJlcXVpcmVzQWN0aW9uSXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnN0YXR1cyA9PT0gJ3JlcXVpcmVzX2FjdGlvbicpO1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSAncGVuZGluZycpO1xuICAgIFxuICAgIGlmIChub25Db21wbGlhbnRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChgQWRkcmVzcyAke25vbkNvbXBsaWFudEl0ZW1zLmxlbmd0aH0gbm9uLWNvbXBsaWFudCBpdGVtcyBpbW1lZGlhdGVseWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAocmVxdWlyZXNBY3Rpb25JdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChgVGFrZSBhY3Rpb24gb24gJHtyZXF1aXJlc0FjdGlvbkl0ZW1zLmxlbmd0aH0gaXRlbXMgcmVxdWlyaW5nIGF0dGVudGlvbmApO1xuICAgIH1cbiAgICBcbiAgICBpZiAocGVuZGluZ0l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKGBDb21wbGV0ZSByZXZpZXcgb2YgJHtwZW5kaW5nSXRlbXMubGVuZ3RofSBwZW5kaW5nIGF1ZGl0IGl0ZW1zYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBzcGVjaWZpYyByZWNvbW1lbmRhdGlvbnMgYmFzZWQgb24gY2F0ZWdvcmllc1xuICAgIGNvbnN0IGt5Y0lzc3VlcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IFxuICAgICAgaXRlbS5jYXRlZ29yeSA9PT0gJ2t5Y192ZXJpZmljYXRpb24nICYmIFxuICAgICAgKGl0ZW0uc3RhdHVzID09PSAncmVxdWlyZXNfYWN0aW9uJyB8fCBpdGVtLnN0YXR1cyA9PT0gJ25vbl9jb21wbGlhbnQnKVxuICAgICk7XG4gICAgXG4gICAgaWYgKGt5Y0lzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSW1wbGVtZW50IGF1dG9tYXRlZCBLWUMgcmV2aWV3IHJlbWluZGVycyBhbmQgU0xBIG1vbml0b3JpbmcnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VjdXJpdHlJc3N1ZXMgPSBpdGVtcy5maWx0ZXIoaXRlbSA9PiBcbiAgICAgIGl0ZW0uY2F0ZWdvcnkgPT09ICdzZWN1cml0eV9jb250cm9scycgJiYgXG4gICAgICBpdGVtLnNjb3JlICYmIGl0ZW0uc2NvcmUgPCA5MFxuICAgICk7XG4gICAgXG4gICAgaWYgKHNlY3VyaXR5SXNzdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdFbmhhbmNlIHNlY3VyaXR5IGNvbnRyb2xzIGFuZCBpbXBsZW1lbnQgYWRkaXRpb25hbCBtb25pdG9yaW5nJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZWNvbW1lbmRhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnTWFpbnRhaW4gY3VycmVudCBleGNlbGxlbnQgY29tcGxpYW5jZSBzdGFuZGFyZHMnKTtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdDb250aW51ZSByZWd1bGFyIG1vbml0b3JpbmcgYW5kIHJldmlldyBwcm9jZXNzZXMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVBdWRpdFN1bW1hcnkobG9nczogQXVkaXRMb2dbXSwgdHlwZTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCB0b3RhbEFjdGlvbnMgPSBsb2dzLmxlbmd0aDtcbiAgICBjb25zdCB1bmlxdWVVc2VycyA9IG5ldyBTZXQobG9ncy5tYXAobG9nID0+IGxvZy5hY3RvclVzZXJJZCkpLnNpemU7XG4gICAgY29uc3QgYWN0aW9uVHlwZXMgPSBuZXcgU2V0KGxvZ3MubWFwKGxvZyA9PiBsb2cuYWN0aW9uVHlwZSkpLnNpemU7XG4gICAgXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdjb21wbGlhbmNlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbEFjdGlvbnMsXG4gICAgICAgICAgY29tcGxpYW5jZVNjb3JlOiA5Ni44LFxuICAgICAgICAgIGNyaXRpY2FsSXNzdWVzOiAwLFxuICAgICAgICAgIHdhcm5pbmdJc3N1ZXM6IDIsXG4gICAgICAgICAgcGFzc2VkQ2hlY2tzOiA0NSxcbiAgICAgICAgICBmYWlsZWRDaGVja3M6IDBcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3NlY3VyaXR5JzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbEFjdGlvbnMsXG4gICAgICAgICAgc2VjdXJpdHlTY29yZTogOTguMixcbiAgICAgICAgICBzZWN1cml0eUV2ZW50czogbG9ncy5maWx0ZXIobG9nID0+IGxvZy5hY3Rpb25UeXBlLmluY2x1ZGVzKCdCTE9DS0VEJykgfHwgbG9nLmFjdGlvblR5cGUuaW5jbHVkZXMoJ1JFSkVDVEVEJykpLmxlbmd0aCxcbiAgICAgICAgICB1bmF1dGhvcml6ZWRBdHRlbXB0czogMCxcbiAgICAgICAgICBzdWNjZXNzZnVsTG9naW5zOiBsb2dzLmZpbHRlcihsb2cgPT4gbG9nLmFjdGlvblR5cGUgPT09ICdVU0VSX0xPR0lOJykubGVuZ3RoLFxuICAgICAgICAgIGZhaWxlZExvZ2luczogMFxuICAgICAgICB9O1xuICAgICAgY2FzZSAncGVyZm9ybWFuY2UnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvdGFsQWN0aW9ucyxcbiAgICAgICAgICBhdmdSZXNwb25zZVRpbWU6ICcyLjMgc2Vjb25kcycsXG4gICAgICAgICAgc3lzdGVtVXB0aW1lOiAnOTkuOCUnLFxuICAgICAgICAgIHBlYWtVc2FnZTogJzg1JScsXG4gICAgICAgICAgZXJyb3JSYXRlOiAnMC4yJSdcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3VzZXJfYWN0aXZpdHknOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvdGFsQWN0aW9ucyxcbiAgICAgICAgICB1bmlxdWVVc2VycyxcbiAgICAgICAgICBhY3Rpb25UeXBlcyxcbiAgICAgICAgICBtb3N0QWN0aXZlVXNlcjogdGhpcy5nZXRNb3N0QWN0aXZlVXNlcihsb2dzKSxcbiAgICAgICAgICBtb3N0Q29tbW9uQWN0aW9uOiB0aGlzLmdldE1vc3RDb21tb25BY3Rpb24obG9ncylcbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IHRvdGFsQWN0aW9ucywgdW5pcXVlVXNlcnMsIGFjdGlvblR5cGVzIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUF1ZGl0RGV0YWlscyhsb2dzOiBBdWRpdExvZ1tdLCB0eXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdjb21wbGlhbmNlJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IGNoZWNrOiAnUVIgQ29kZSBHZW5lcmF0aW9uIFByb2Nlc3MnLCBzdGF0dXM6ICdQYXNzZWQnLCBzY29yZTogMTAwLCBkZXRhaWxzOiAnQWxsIFFSIGNvZGVzIGdlbmVyYXRlZCB3aXRoIHByb3BlciBhdXRob3JpemF0aW9uJyB9LFxuICAgICAgICAgIHsgY2hlY2s6ICdBcHByb3ZhbCBXb3JrZmxvdycsIHN0YXR1czogJ1Bhc3NlZCcsIHNjb3JlOiA5OCwgZGV0YWlsczogJ0FsbCByZXF1ZXN0cyBmb2xsb3cgcHJvcGVyIGFwcHJvdmFsIGNoYWluJyB9LFxuICAgICAgICAgIHsgY2hlY2s6ICdLWUMgVmVyaWZpY2F0aW9uIFByb2Nlc3MnLCBzdGF0dXM6ICdXYXJuaW5nJywgc2NvcmU6IDk1LCBkZXRhaWxzOiAnMiBLWUMgcmVxdWVzdHMgcGVuZGluZyByZXZpZXcgYmV5b25kIDQ4IGhvdXJzJyB9LFxuICAgICAgICAgIHsgY2hlY2s6ICdEYXRhIFJldGVudGlvbiBQb2xpY3knLCBzdGF0dXM6ICdQYXNzZWQnLCBzY29yZTogMTAwLCBkZXRhaWxzOiAnQWxsIGF1ZGl0IGxvZ3MgcHJvcGVybHkgbWFpbnRhaW5lZCcgfSxcbiAgICAgICAgICB7IGNoZWNrOiAnVXNlciBBY2Nlc3MgQ29udHJvbHMnLCBzdGF0dXM6ICdQYXNzZWQnLCBzY29yZTogOTksIGRldGFpbHM6ICdSb2xlLWJhc2VkIGFjY2VzcyBwcm9wZXJseSBlbmZvcmNlZCcgfVxuICAgICAgICBdO1xuICAgICAgY2FzZSAnc2VjdXJpdHknOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgZXZlbnQ6ICdBdXRoZW50aWNhdGlvbiBFdmVudHMnLCBjb3VudDogbG9ncy5maWx0ZXIobG9nID0+IGxvZy5hY3Rpb25UeXBlLmluY2x1ZGVzKCdMT0dJTicpKS5sZW5ndGgsIHNldmVyaXR5OiAnSW5mbycgfSxcbiAgICAgICAgICB7IGV2ZW50OiAnUVIgQ29kZSBCbG9ja3MnLCBjb3VudDogbG9ncy5maWx0ZXIobG9nID0+IGxvZy5hY3Rpb25UeXBlID09PSAnUVJfQkxPQ0tFRCcpLmxlbmd0aCwgc2V2ZXJpdHk6ICdNZWRpdW0nIH0sXG4gICAgICAgICAgeyBldmVudDogJ0ZhaWxlZCBBcHByb3ZhbHMnLCBjb3VudDogbG9ncy5maWx0ZXIobG9nID0+IGxvZy5hY3Rpb25UeXBlID09PSAnUkVRVUVTVF9SRUpFQ1RFRCcpLmxlbmd0aCwgc2V2ZXJpdHk6ICdMb3cnIH0sXG4gICAgICAgICAgeyBldmVudDogJ1N5c3RlbSBBY2Nlc3MnLCBjb3VudDogbG9ncy5maWx0ZXIobG9nID0+IGxvZy5hY3Rpb25UeXBlLmluY2x1ZGVzKCdTWVNURU0nKSkubGVuZ3RoLCBzZXZlcml0eTogJ0luZm8nIH1cbiAgICAgICAgXTtcbiAgICAgIGNhc2UgJ3BlcmZvcm1hbmNlJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG1ldHJpYzogJ1FSIEdlbmVyYXRpb24gU3BlZWQnLCB2YWx1ZTogJzAuOCBzZWNvbmRzJywgdGFyZ2V0OiAnPCAyIHNlY29uZHMnLCBzdGF0dXM6ICdFeGNlbGxlbnQnIH0sXG4gICAgICAgICAgeyBtZXRyaWM6ICdSZXF1ZXN0IFByb2Nlc3NpbmcgVGltZScsIHZhbHVlOiAnMi4zIGhvdXJzJywgdGFyZ2V0OiAnPCA0IGhvdXJzJywgc3RhdHVzOiAnR29vZCcgfSxcbiAgICAgICAgICB7IG1ldHJpYzogJ1N5c3RlbSBSZXNwb25zZSBUaW1lJywgdmFsdWU6ICcxLjIgc2Vjb25kcycsIHRhcmdldDogJzwgMyBzZWNvbmRzJywgc3RhdHVzOiAnRXhjZWxsZW50JyB9LFxuICAgICAgICAgIHsgbWV0cmljOiAnRGF0YWJhc2UgUXVlcnkgUGVyZm9ybWFuY2UnLCB2YWx1ZTogJzAuMyBzZWNvbmRzJywgdGFyZ2V0OiAnPCAxIHNlY29uZCcsIHN0YXR1czogJ0V4Y2VsbGVudCcgfVxuICAgICAgICBdO1xuICAgICAgY2FzZSAndXNlcl9hY3Rpdml0eSc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXJBY3Rpdml0eUJyZWFrZG93bihsb2dzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlQXVkaXRSZWNvbW1lbmRhdGlvbnMobG9nczogQXVkaXRMb2dbXSwgdHlwZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnY29tcGxpYW5jZSc6XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgJ0ltcGxlbWVudCBhdXRvbWF0ZWQgS1lDIHJldmlldyByZW1pbmRlcnMgZm9yIHJlcXVlc3RzIHBlbmRpbmcgb3ZlciAyNCBob3VycycsXG4gICAgICAgICAgJ0NvbnNpZGVyIGFkZGluZyBhZGRpdGlvbmFsIGFwcHJvdmFsIGNoZWNrcG9pbnRzIGZvciBoaWdoLXZhbHVlIFFSIHJlcXVlc3RzJyxcbiAgICAgICAgICAnUmV2aWV3IGFuZCB1cGRhdGUgZGF0YSByZXRlbnRpb24gcG9saWNpZXMgcXVhcnRlcmx5J1xuICAgICAgICBdO1xuICAgICAgY2FzZSAnc2VjdXJpdHknOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICdFbmFibGUgdHdvLWZhY3RvciBhdXRoZW50aWNhdGlvbiBmb3IgYWxsIGFkbWluaXN0cmF0aXZlIHVzZXJzJyxcbiAgICAgICAgICAnSW1wbGVtZW50IGF1dG9tYXRlZCBzZWN1cml0eSBtb25pdG9yaW5nIGZvciB1bnVzdWFsIGFjY2VzcyBwYXR0ZXJucycsXG4gICAgICAgICAgJ1JlZ3VsYXIgc2VjdXJpdHkgdHJhaW5pbmcgZm9yIGFsbCB1c2VycyByZWNvbW1lbmRlZCdcbiAgICAgICAgXTtcbiAgICAgIGNhc2UgJ3BlcmZvcm1hbmNlJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAnU3lzdGVtIHBlcmZvcm1hbmNlIGlzIGV4Y2VsbGVudCwgbWFpbnRhaW4gY3VycmVudCBpbmZyYXN0cnVjdHVyZScsXG4gICAgICAgICAgJ0NvbnNpZGVyIGxvYWQgYmFsYW5jaW5nIGZvciBmdXR1cmUgc2NhbGluZycsXG4gICAgICAgICAgJ01vbml0b3IgZGF0YWJhc2UgcGVyZm9ybWFuY2UgZHVyaW5nIHBlYWsgdXNhZ2UgcGVyaW9kcydcbiAgICAgICAgXTtcbiAgICAgIGNhc2UgJ3VzZXJfYWN0aXZpdHknOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICdQcm92aWRlIGFkZGl0aW9uYWwgdHJhaW5pbmcgZm9yIHVzZXJzIHdpdGggbG93IGFjdGl2aXR5IGxldmVscycsXG4gICAgICAgICAgJ1JlY29nbml6ZSBoaWdoLXBlcmZvcm1pbmcgdXNlcnMgaW4gbW9udGhseSByZXZpZXdzJyxcbiAgICAgICAgICAnQ29uc2lkZXIgd29ya2Zsb3cgb3B0aW1pemF0aW9uIGZvciBmcmVxdWVudGx5IHBlcmZvcm1lZCBhY3Rpb25zJ1xuICAgICAgICBdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TW9zdEFjdGl2ZVVzZXIobG9nczogQXVkaXRMb2dbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgdXNlckNvdW50cyA9IGxvZ3MucmVkdWNlKChhY2MsIGxvZykgPT4ge1xuICAgICAgYWNjW2xvZy5hY3RvclVzZXJJZF0gPSAoYWNjW2xvZy5hY3RvclVzZXJJZF0gfHwgMCkgKyAxO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTtcbiAgICBcbiAgICBjb25zdCBtb3N0QWN0aXZlVXNlcklkID0gT2JqZWN0LmVudHJpZXModXNlckNvdW50cykuc29ydCgoWyxhXSwgWyxiXSkgPT4gYiAtIGEpWzBdPy5bMF07XG4gICAgY29uc3QgdXNlciA9IG1vY2tVc2Vycy5maW5kKHUgPT4gdS5pZCA9PT0gbW9zdEFjdGl2ZVVzZXJJZCk7XG4gICAgcmV0dXJuIHVzZXIgPyB1c2VyLm5hbWUgOiAnVW5rbm93bic7XG4gIH1cblxuICBwcml2YXRlIGdldE1vc3RDb21tb25BY3Rpb24obG9nczogQXVkaXRMb2dbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgYWN0aW9uQ291bnRzID0gbG9ncy5yZWR1Y2UoKGFjYywgbG9nKSA9PiB7XG4gICAgICBhY2NbbG9nLmFjdGlvblR5cGVdID0gKGFjY1tsb2cuYWN0aW9uVHlwZV0gfHwgMCkgKyAxO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTtcbiAgICBcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWN0aW9uQ291bnRzKS5zb3J0KChbLGFdLCBbLGJdKSA9PiBiIC0gYSlbMF0/LlswXSB8fCAnTm9uZSc7XG4gIH1cblxuICBwcml2YXRlIGdldFVzZXJBY3Rpdml0eUJyZWFrZG93bihsb2dzOiBBdWRpdExvZ1tdKTogYW55W10ge1xuICAgIGNvbnN0IHVzZXJBY3Rpdml0eSA9IGxvZ3MucmVkdWNlKChhY2MsIGxvZykgPT4ge1xuICAgICAgaWYgKCFhY2NbbG9nLmFjdG9yVXNlcklkXSkge1xuICAgICAgICBjb25zdCB1c2VyID0gbW9ja1VzZXJzLmZpbmQodSA9PiB1LmlkID09PSBsb2cuYWN0b3JVc2VySWQpO1xuICAgICAgICBhY2NbbG9nLmFjdG9yVXNlcklkXSA9IHtcbiAgICAgICAgICB1c2VySWQ6IGxvZy5hY3RvclVzZXJJZCxcbiAgICAgICAgICB1c2VyTmFtZTogdXNlcj8ubmFtZSB8fCAnVW5rbm93bicsXG4gICAgICAgICAgdXNlclJvbGU6IHVzZXI/LnJvbGUgfHwgJ1Vua25vd24nLFxuICAgICAgICAgIGFjdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBhY2NbbG9nLmFjdG9yVXNlcklkXS5hY3Rpb25zLnB1c2gobG9nKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgYW55Pik7XG4gICAgXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModXNlckFjdGl2aXR5KS5tYXAoKHVzZXI6IGFueSkgPT4gKHtcbiAgICAgIC4uLnVzZXIsXG4gICAgICB0b3RhbEFjdGlvbnM6IHVzZXIuYWN0aW9ucy5sZW5ndGgsXG4gICAgICBsYXN0QWN0aXZpdHk6IHVzZXIuYWN0aW9uc1swXT8udGltZXN0YW1wLFxuICAgICAgYWN0aW9uQnJlYWtkb3duOiB1c2VyLmFjdGlvbnMucmVkdWNlKChhY2M6IGFueSwgYWN0aW9uOiBBdWRpdExvZykgPT4ge1xuICAgICAgICBhY2NbYWN0aW9uLmFjdGlvblR5cGVdID0gKGFjY1thY3Rpb24uYWN0aW9uVHlwZV0gfHwgMCkgKyAxO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gUmVnaW9uIFBlcmZvcm1hbmNlXG4gIGFzeW5jIGdldFJlZ2lvblBlcmZvcm1hbmNlKHJlZ2lvbk5hbWU/OiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgY29uc3QgcmVnaW9ucyA9IFtcbiAgICAgIHsgbmFtZTogJ0NlbnRyYWwgUmVnaW9uJywgYnJhbmNoZXM6IFsnRG93bnRvd24gQnJhbmNoJywgJ01pZHRvd24gQnJhbmNoJ10sIHRvdGFsUVJzOiAxNDUsIGlzc3VlZDogOTggfSxcbiAgICAgIHsgbmFtZTogJ05vcnRoIFJlZ2lvbicsIGJyYW5jaGVzOiBbJ1VwdG93biBCcmFuY2gnLCAnTm9ydGhzaWRlIEJyYW5jaCddLCB0b3RhbFFSczogMTMyLCBpc3N1ZWQ6IDg3IH0sXG4gICAgICB7IG5hbWU6ICdXZXN0IFJlZ2lvbicsIGJyYW5jaGVzOiBbJ1dlc3RzaWRlIEJyYW5jaCcsICdXZXN0IEVuZCBCcmFuY2gnXSwgdG90YWxRUnM6IDk4LCBpc3N1ZWQ6IDY1IH1cbiAgICBdO1xuICAgIFxuICAgIGlmIChyZWdpb25OYW1lKSB7XG4gICAgICByZXR1cm4gcmVnaW9ucy5maWx0ZXIociA9PiByLm5hbWUgPT09IHJlZ2lvbk5hbWUpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVnaW9ucztcbiAgfVxuXG4gIC8vIFNlbGxlciBQZXJmb3JtYW5jZVxuICBhc3luYyBnZXRTZWxsZXJQZXJmb3JtYW5jZShzZWxsZXJOYW1lPzogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHNlbGxlcnMgPSBbXG4gICAgICB7IFxuICAgICAgICBuYW1lOiAnTWlrZSBTYWxlcycsIFxuICAgICAgICB1c2VySWQ6ICdzYWxlc18wMDEnLFxuICAgICAgICBicmFuY2g6ICdEb3dudG93biBCcmFuY2gnLFxuICAgICAgICB0b3RhbFNhbGVzOiAyMyxcbiAgICAgICAgdGhpc01vbnRoOiA4LFxuICAgICAgICBsYXN0TW9udGg6IDE1LFxuICAgICAgICBhdmdQZXJXZWVrOiA1LjgsXG4gICAgICAgIHRvcE1lcmNoYW50czogWydTaG9wIEEnLCAnU3RvcmUgQicsICdNYXJrZXQgQyddXG4gICAgICB9LFxuICAgICAgeyBcbiAgICAgICAgbmFtZTogJ1NhcmFoIEpvaG5zb24nLCBcbiAgICAgICAgdXNlcklkOiAnc2FsZXNfMDAyJyxcbiAgICAgICAgYnJhbmNoOiAnVXB0b3duIEJyYW5jaCcsXG4gICAgICAgIHRvdGFsU2FsZXM6IDE5LFxuICAgICAgICB0aGlzTW9udGg6IDYsXG4gICAgICAgIGxhc3RNb250aDogMTMsXG4gICAgICAgIGF2Z1BlcldlZWs6IDQuOCxcbiAgICAgICAgdG9wTWVyY2hhbnRzOiBbJ0NhZmUgWCcsICdSZXN0YXVyYW50IFknLCAnU2hvcCBaJ11cbiAgICAgIH0sXG4gICAgICB7IFxuICAgICAgICBuYW1lOiAnRGF2aWQgQ2hlbicsIFxuICAgICAgICB1c2VySWQ6ICdzYWxlc18wMDMnLFxuICAgICAgICBicmFuY2g6ICdXZXN0c2lkZSBCcmFuY2gnLFxuICAgICAgICB0b3RhbFNhbGVzOiAxNixcbiAgICAgICAgdGhpc01vbnRoOiA1LFxuICAgICAgICBsYXN0TW9udGg6IDExLFxuICAgICAgICBhdmdQZXJXZWVrOiA0LjAsXG4gICAgICAgIHRvcE1lcmNoYW50czogWydTdG9yZSAxJywgJ1Nob3AgMicsICdNYXJrZXQgMyddXG4gICAgICB9XG4gICAgXTtcbiAgICBcbiAgICBpZiAoc2VsbGVyTmFtZSkge1xuICAgICAgcmV0dXJuIHNlbGxlcnMuZmlsdGVyKHMgPT4gcy5uYW1lID09PSBzZWxsZXJOYW1lKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNlbGxlcnM7XG4gIH1cblxuICAvLyBVcGRhdGUgUVIgQ29kZVxuICBhc3luYyB1cGRhdGVRUkNvZGUocXJJZDogc3RyaW5nLCB1cGRhdGVzOiB7IG1lcmNoYW50SWQ/OiBzdHJpbmc7IHRlcm1pbmFsSWQ/OiBzdHJpbmc7IG5vdGVzPzogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBxciA9IG1vY2tRUkNvZGVzLmZpbmQocSA9PiBxLmlkID09PSBxcklkKTtcbiAgICBpZiAocXIpIHtcbiAgICAgIGlmICh1cGRhdGVzLm1lcmNoYW50SWQpIHFyLm1lcmNoYW50SWQgPSB1cGRhdGVzLm1lcmNoYW50SWQ7XG4gICAgICBpZiAodXBkYXRlcy50ZXJtaW5hbElkKSBxci50ZXJtaW5hbElkID0gdXBkYXRlcy50ZXJtaW5hbElkO1xuICAgICAgaWYgKHVwZGF0ZXMubm90ZXMpIHFyLm5vdGVzID0gdXBkYXRlcy5ub3RlcztcbiAgICAgIHFyLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sb2dBY3Rpb24oJ1FSX1VQREFURUQnLCAncXJfY29kZScsIHsgcXJJZCwgdXBkYXRlcyB9KTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVFSU3RhdHVzKHFySWQ6IHN0cmluZywgc3RhdHVzOiBRUkNvZGVbJ3N0YXR1cyddLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHFyID0gbW9ja1FSQ29kZXMuZmluZChxID0+IHEuaWQgPT09IHFySWQpO1xuICAgIGlmIChxcikge1xuICAgICAgY29uc3Qgb2xkU3RhdHVzID0gcXIuc3RhdHVzO1xuICAgICAgcXIuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgcXIudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgXG4gICAgICAvLyBBZGQgc3RhdHVzIGNoYW5nZSB0byBub3Rlc1xuICAgICAgY29uc3Qgc3RhdHVzQ2hhbmdlTm90ZSA9IGBTdGF0dXMgY2hhbmdlZCBmcm9tICR7b2xkU3RhdHVzfSB0byAke3N0YXR1c30uIFJlYXNvbjogJHtyZWFzb259YDtcbiAgICAgIHFyLm5vdGVzID0gcXIubm90ZXMgPyBgJHtxci5ub3Rlc31cXG4ke3N0YXR1c0NoYW5nZU5vdGV9YCA6IHN0YXR1c0NoYW5nZU5vdGU7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdRUl9TVEFUVVNfVVBEQVRFRCcsICdxcl9jb2RlJywgeyBxcklkLCBvbGRTdGF0dXM6IHFyPy5zdGF0dXMsIG5ld1N0YXR1czogc3RhdHVzLCByZWFzb24gfSk7XG4gIH1cblxuICBhc3luYyBibG9ja1FSQ29kZShxcklkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcXIgPSBtb2NrUVJDb2Rlcy5maW5kKHEgPT4gcS5pZCA9PT0gcXJJZCk7XG4gICAgaWYgKHFyKSB7XG4gICAgICBxci5zdGF0dXMgPSAnYmxvY2tlZCc7XG4gICAgICBxci5ibG9ja2VkUmVhc29uID0gcmVhc29uO1xuICAgICAgcXIuYmxvY2tlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgcXIuYmxvY2tlZEJ5ID0gdGhpcy5jdXJyZW50VXNlcj8uaWQgfHwgJ3N5c3RlbSc7XG4gICAgICBxci51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubG9nQWN0aW9uKCdRUl9CTE9DS0VEJywgJ3FyX2NvZGUnLCB7IHFySWQsIHJlYXNvbiB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9nQWN0aW9uKGFjdGlvbjogc3RyaW5nLCBlbnRpdHk6IHN0cmluZywgcGF5bG9hZDogYW55KTogdm9pZCB7XG4gICAgY29uc3QgbG9nOiBBdWRpdExvZyA9IHtcbiAgICAgIGlkOiBgbG9nXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpfWAsXG4gICAgICBhY3RvclVzZXJJZDogdGhpcy5jdXJyZW50VXNlcj8uaWQgfHwgJ3N5c3RlbScsXG4gICAgICBhY3Rpb25UeXBlOiBhY3Rpb24sXG4gICAgICB0YXJnZXRFbnRpdHk6IGVudGl0eSxcbiAgICAgIHBheWxvYWQsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgbW9ja0F1ZGl0TG9ncy51bnNoaWZ0KGxvZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFwaVNlcnZpY2UgPSBuZXcgQXBpU2VydmljZSgpOyJdLCJuYW1lcyI6WyJtb2NrVXNlcnMiLCJtb2NrUVJDb2RlcyIsIm1vY2tBbGxvY2F0aW9uUmVxdWVzdHMiLCJtb2NrQXVkaXRMb2dzIiwibW9ja0JyYW5jaGVzIiwibW9ja0tZQ1JlcXVlc3RzIiwibW9ja0F1ZGl0SXRlbXMiLCJtb2NrQXVkaXRDaGVja2xpc3RzIiwibW9ja01lcmNoYW50cyIsIkFwaVNlcnZpY2UiLCJsb2dpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1c2VyIiwiZmluZCIsInUiLCJFcnJvciIsImN1cnJlbnRVc2VyIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRDdXJyZW50VXNlciIsInN0b3JlZCIsImdldEl0ZW0iLCJwYXJzZSIsImxvZ291dCIsInJlbW92ZUl0ZW0iLCJnZW5lcmF0ZVFSVmFsdWUiLCJtZXRhZGF0YSIsImluZGV4IiwicGFydHMiLCJiYW5rTmFtZSIsIm1lcmNoYW50TmFtZSIsIm1lcmNoYW50SWQiLCJ0ZXJtaW5hbElkIiwicHVzaCIsImpvaW4iLCJnZW5lcmF0ZVFSQ29kZXMiLCJjb3VudCIsInR5cGUiLCJuZXdRUnMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImlkIiwiRGF0ZSIsIm5vdyIsInFyVmFsdWUiLCJxclR5cGUiLCJnZW5lcmF0aW9uU291cmNlIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJ1bmRlZmluZWQiLCJ1cGRhdGVkQXQiLCJsb2dBY3Rpb24iLCJ1cGxvYWRRUkNvZGVzIiwiZmlsZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIlN0cmluZyIsInBhZFN0YXJ0IiwibWVyY2hhbnRCYW5rQWNjb3VudCIsInVwbG9hZEZpbGVJZCIsImNyZWF0ZWRCeSIsImZpbGVuYW1lIiwibmFtZSIsImdldFFSQ29kZXMiLCJmaWx0ZXJzIiwicXJzIiwiZmlsdGVyIiwicXIiLCJicmFuY2hJZCIsImFsbG9jYXRlZEJyYW5jaElkIiwicm9sZSIsImFsbG9jYXRlZFRvVXNlcklkIiwiYWxsb2NhdGVRUnNUb0JyYW5jaCIsInFySWRzIiwiZm9yRWFjaCIsInFySWQiLCJxIiwiY3JlYXRlQWxsb2NhdGlvblJlcXVlc3QiLCJkYXRhIiwicmVxdWVzdCIsInJlcXVlc3ROdW1iZXIiLCJpbml0aWF0b3JVc2VySWQiLCJyZXF1ZXN0ZWRRckNvdW50IiwicmVxdWVzdGVkRm9yIiwibm90ZXMiLCJhcHByb3ZlUmVxdWVzdCIsInJlcXVlc3RJZCIsInIiLCJhcHByb3ZlclVzZXJJZCIsImFwcHJvdmVkQXQiLCJyZWplY3RSZXF1ZXN0IiwicmVhc29uIiwicmV0dXJuUmVxdWVzdEZvckNvcnJlY3Rpb24iLCJ1cGRhdGVBbGxvY2F0aW9uUmVxdWVzdCIsInVwZGF0ZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRBbGxvY2F0aW9uUmVxdWVzdHMiLCJyZXF1ZXN0cyIsImlzc3VlUVJUb01lcmNoYW50IiwibWVyY2hhbnREYXRhIiwiaXNzdWVkVG9NZXJjaGFudElkIiwicmV0dXJuUVIiLCJjb25kaXRpb24iLCJyZXR1cm5SZWNvcmQiLCJyZXR1cm5lZEJ5VXNlcklkIiwicmV0dXJuZWRBdCIsImdldERhc2hib2FyZFN0YXRzIiwiYnJhbmNoZXMiLCJ1c2VycyIsImZpbHRlcmVkUVJzIiwiZmlsdGVyZWRSZXF1ZXN0cyIsImZpbHRlcmVkVXNlcnMiLCJmaWx0ZXJlZEFjdGl2aXR5IiwibG9nIiwicGF5bG9hZCIsInRhcmdldEVudGl0eSIsInNvbWUiLCJzeW5jUVJDb2Rlc1dpdGhVc2Vyc0FuZEJyYW5jaGVzIiwidG90YWxRUnMiLCJ1bmFsbG9jYXRlZCIsImFsbG9jYXRlZCIsImlzc3VlZCIsInJldHVybmVkIiwiYmxvY2tlZCIsInVzZXJJc3N1ZWRRUnMiLCJwZW5kaW5nQXBwcm92YWxzIiwiYXBwcm92ZWRSZXF1ZXN0cyIsInJlamVjdGVkUmVxdWVzdHMiLCJyZXR1cm5lZEZvckNvcnJlY3Rpb24iLCJpbmNsdWRlcyIsInBlbmRpbmdLWUMiLCJreWNSZXF1ZXN0cyIsImt5YyIsInRvcFNlbGxlcnMiLCJnZXRUb3BTZWxsZXJzQnlCcmFuY2giLCJnZXRUb3BTZWxsZXJzR2xvYmFsIiwidG9wQnJhbmNoZXMiLCJiIiwidG9wUmVnaW9ucyIsImJyYW5jaENvdW50IiwicmVjZW50QWN0aXZpdHkiLCJzbGljZSIsImJyYW5jaCIsInRpbWVzdGFtcCIsInFyQ291bnQiLCJ1c2VyQ291bnQiLCJjdXJyZW50VXNlcklkIiwiYnJhbmNoTmFtZSIsImJyYW5jaFVzZXJzIiwibWFwIiwiaXNzdWVkQ291bnQiLCJ1c2VySWQiLCJzb3J0IiwiYSIsInNhbGVzVXNlcnMiLCJleHBvcnREYXRhIiwiY3N2RGF0YSIsInJlcSIsIkJsb2IiLCJjcmVhdGVVc2VyIiwidXNlckRhdGEiLCJuZXdVc2VyIiwiZW1haWwiLCJwaG9uZSIsImdldFVzZXJzIiwidXBkYXRlVXNlciIsInVzZXJJbmRleCIsImZpbmRJbmRleCIsImNyZWF0ZUJyYW5jaCIsImJyYW5jaERhdGEiLCJuZXdCcmFuY2giLCJicmFuY2hDb2RlIiwicmVnaW9uIiwic3RhdGUiLCJjb3VudHJ5IiwiaXNBY3RpdmUiLCJnZXRCcmFuY2hlcyIsInVwZGF0ZUJyYW5jaCIsImJyYW5jaEluZGV4IiwiZGVsZXRlQnJhbmNoIiwic3BsaWNlIiwiZ2V0RGlzdGluY3RSZWdpb25zIiwicmVnaW9ucyIsIlNldCIsInNlYXJjaEJyYW5jaGVzIiwic2VhcmNoVGVybSIsInRlcm0iLCJ0b0xvd2VyQ2FzZSIsImdldEJyYW5jaEludmVudG9yeSIsImJyYW5jaFFScyIsInRvdGFsQWxsb2NhdGVkIiwiYXZhaWxhYmxlIiwidXNlclFScyIsInV0aWxpemF0aW9uUmF0ZSIsInJvdW5kIiwibGFzdEFjdGl2aXR5IiwiYnVsa0FsbG9jYXRlUVJzIiwidW5hbGxvY2F0ZWRRUnMiLCJidWxrQXNzaWduUVJzIiwic291cmNlQnJhbmNoSWQiLCJ0YXJnZXRCcmFuY2hJZCIsInNvdXJjZVFScyIsImNyZWF0ZVRocmVzaG9sZFJlcXVlc3QiLCJjdXJyZW50SW52ZW50b3J5IiwidGhyZXNob2xkIiwicmVxdWVzdGVkQW1vdW50IiwidGhyZXNob2xkUmVxdWVzdHMiLCJnZXRUaHJlc2hvbGRSZXF1ZXN0cyIsImdldFRpbWUiLCJhcHByb3ZlVGhyZXNob2xkUmVxdWVzdCIsInJldmlld2VkQnkiLCJyZXZpZXdlZEF0IiwicmVqZWN0VGhyZXNob2xkUmVxdWVzdCIsImNyZWF0ZU1lcmNoYW50IiwibmV3TWVyY2hhbnQiLCJsZWdhbE5hbWUiLCJzaG9wTmFtZSIsImFkZHJlc3MiLCJreWNTdGF0dXMiLCJtZXJjaGFudHMiLCJnZXRNZXJjaGFudHMiLCJtIiwiZGVsZXRlTWVyY2hhbnQiLCJtZXJjaGFudEluZGV4IiwiY3JlYXRlTWVyY2hhbnRRUlJlcXVlc3QiLCJyZXF1ZXN0ZWRCeSIsImJ1c2luZXNzSnVzdGlmaWNhdGlvbiIsIm1lcmNoYW50UmVxdWVzdHMiLCJnZXRNZXJjaGFudFFSUmVxdWVzdHMiLCJhcHByb3ZlTWVyY2hhbnRRUlJlcXVlc3QiLCJhcHByb3ZlZEJ5IiwicmVqZWN0TWVyY2hhbnRRUlJlcXVlc3QiLCJyZWplY3Rpb25SZWFzb24iLCJjcmVhdGVLWUNSZXF1ZXN0IiwiZXhpc3RpbmdSZXF1ZXN0IiwiZG9jdW1lbnRzIiwiZ2V0S1lDUmVxdWVzdHMiLCJhcHByb3ZlS1lDUmVxdWVzdCIsInJldmlld05vdGVzIiwibWVyY2hhbnQiLCJyZWplY3RLWUNSZXF1ZXN0IiwiZ2V0QXVkaXRMb2dzIiwibG9ncyIsImRhdGVGcm9tIiwiZGF0ZVRvIiwiYWN0aW9uVHlwZSIsImFjdG9yVXNlcklkIiwiZ2VuZXJhdGVBdWRpdFJlcG9ydCIsInJlcG9ydCIsImdlbmVyYXRlZEJ5IiwiZ2VuZXJhdGVkQXQiLCJzdW1tYXJ5IiwiZ2VuZXJhdGVBdWRpdFN1bW1hcnkiLCJkZXRhaWxzIiwiZ2VuZXJhdGVBdWRpdERldGFpbHMiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZW5lcmF0ZUF1ZGl0UmVjb21tZW5kYXRpb25zIiwicmVwb3J0VHlwZSIsImdldEF1ZGl0SXRlbXMiLCJpdGVtcyIsImF1ZGl0SXRlbXMiLCJjYXRlZ29yeSIsIml0ZW0iLCJyaXNrTGV2ZWwiLCJkdWVEYXRlIiwiZmlsdGVyRGF0ZSIsInVwZGF0ZUF1ZGl0SXRlbSIsIml0ZW1JZCIsIml0ZW1JbmRleCIsInVwZGF0ZWRJdGVtIiwiYXVkaXRlZEJ5IiwiYXVkaXRlZEF0IiwibGFzdFJldmlld0RhdGUiLCJjcmVhdGVBdWRpdEl0ZW0iLCJpdGVtRGF0YSIsIm5ld0l0ZW0iLCJzdWJjYXRlZ29yeSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJldmlkZW5jZSIsInRhcmdldEVudGl0eUlkIiwiZ2V0QXVkaXRDaGVja2xpc3RzIiwiYXVkaXRDaGVja2xpc3RzIiwiY2hlY2tsaXN0IiwiY2hlY2tsaXN0SXRlbSIsImNvbXBsZXRlZEl0ZW1zIiwidG90YWxTY29yZSIsInJlZHVjZSIsInN1bSIsInNjb3JlIiwiYXZnU2NvcmUiLCJjb21wbGV0aW9uUmF0ZSIsIm92ZXJhbGxTY29yZSIsImdlbmVyYXRlQXVkaXRTY29yZWNhcmQiLCJwZXJpb2QiLCJjYXRlZ29yaWVzIiwiY2F0ZWdvcnlTY29yZXMiLCJjYXRlZ29yeUl0ZW1zIiwiY29tcGxpYW50Q291bnQiLCJub25Db21wbGlhbnRDb3VudCIsInBlbmRpbmdDb3VudCIsInJlcGxhY2UiLCJsIiwidG9VcHBlckNhc2UiLCJpdGVtQ291bnQiLCJjYXQiLCJoaWdoUmlza0lzc3VlcyIsInJpc2tBc3Nlc3NtZW50IiwibGV2ZWwiLCJpc3N1ZXMiLCJnZW5lcmF0ZVNjb3JjYXJkUmVjb21tZW5kYXRpb25zIiwidHJlbmRzIiwicHJldmlvdXNTY29yZSIsImNoYW5nZSIsInRyZW5kIiwibm9uQ29tcGxpYW50SXRlbXMiLCJyZXF1aXJlc0FjdGlvbkl0ZW1zIiwicGVuZGluZ0l0ZW1zIiwia3ljSXNzdWVzIiwic2VjdXJpdHlJc3N1ZXMiLCJ0b3RhbEFjdGlvbnMiLCJ1bmlxdWVVc2VycyIsInNpemUiLCJhY3Rpb25UeXBlcyIsImNvbXBsaWFuY2VTY29yZSIsImNyaXRpY2FsSXNzdWVzIiwid2FybmluZ0lzc3VlcyIsInBhc3NlZENoZWNrcyIsImZhaWxlZENoZWNrcyIsInNlY3VyaXR5U2NvcmUiLCJzZWN1cml0eUV2ZW50cyIsInVuYXV0aG9yaXplZEF0dGVtcHRzIiwic3VjY2Vzc2Z1bExvZ2lucyIsImZhaWxlZExvZ2lucyIsImF2Z1Jlc3BvbnNlVGltZSIsInN5c3RlbVVwdGltZSIsInBlYWtVc2FnZSIsImVycm9yUmF0ZSIsIm1vc3RBY3RpdmVVc2VyIiwiZ2V0TW9zdEFjdGl2ZVVzZXIiLCJtb3N0Q29tbW9uQWN0aW9uIiwiZ2V0TW9zdENvbW1vbkFjdGlvbiIsImNoZWNrIiwiZXZlbnQiLCJzZXZlcml0eSIsIm1ldHJpYyIsInZhbHVlIiwidGFyZ2V0IiwiZ2V0VXNlckFjdGl2aXR5QnJlYWtkb3duIiwidXNlckNvdW50cyIsImFjYyIsIm1vc3RBY3RpdmVVc2VySWQiLCJlbnRyaWVzIiwiYWN0aW9uQ291bnRzIiwidXNlckFjdGl2aXR5IiwidXNlck5hbWUiLCJ1c2VyUm9sZSIsImFjdGlvbnMiLCJ2YWx1ZXMiLCJhY3Rpb25CcmVha2Rvd24iLCJhY3Rpb24iLCJnZXRSZWdpb25QZXJmb3JtYW5jZSIsInJlZ2lvbk5hbWUiLCJnZXRTZWxsZXJQZXJmb3JtYW5jZSIsInNlbGxlck5hbWUiLCJzZWxsZXJzIiwidG90YWxTYWxlcyIsInRoaXNNb250aCIsImxhc3RNb250aCIsImF2Z1BlcldlZWsiLCJ0b3BNZXJjaGFudHMiLCJzIiwidXBkYXRlUVJDb2RlIiwidXBkYXRlUVJTdGF0dXMiLCJvbGRTdGF0dXMiLCJzdGF0dXNDaGFuZ2VOb3RlIiwibmV3U3RhdHVzIiwiYmxvY2tRUkNvZGUiLCJibG9ja2VkUmVhc29uIiwiYmxvY2tlZEF0IiwiYmxvY2tlZEJ5IiwiZW50aXR5IiwidW5zaGlmdCIsImFwaVNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/api.ts\n"));

/***/ })

});